var isFullscreen = false;
var tapSkipped = true;
function EnableFullScreen(isFullscreen)
{
	if ( !isFullscreen ) {

		if ( container.requestFullscreen ) { container.requestFullscreen(); }
		if ( container.msRequestFullscreen ) { container.msRequestFullscreen(); }
		if ( container.mozRequestFullScreen ) { container.mozRequestFullScreen(); }
		if ( container.webkitRequestFullscreen ) { container.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT ); }
	  
		isFullscreen = true;

	} else {

		if ( document.exitFullscreen ) { document.exitFullscreen(); }
		if ( document.msExitFullscreen ) { document.msExitFullscreen(); }
		if ( document.mozCancelFullScreen ) { document.mozCancelFullScreen(); }
		if ( document.webkitExitFullscreen ) { document.webkitExitFullscreen( ); }

		isFullscreen = false;

	}
	return isFullscreen;
}

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :
	typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :
	(global = global || self, factory(global.PANOLENS = {}, global.THREE));
}(this, function (exports, THREE) { 'use strict';

	const version="0.11.0";const dependencies={three:"^0.105.2"};

	/**
	 * REVISION
	 * @module REVISION
	 * @example PANOLENS.REVISION
	 * @type {string} revision
	 */
	const REVISION = version.split( '.' )[ 1 ];

	/**
	 * VERSION
	 * @module VERSION
	 * @example PANOLENS.VERSION
	 * @type {string} version
	 */
	const VERSION = version;

	/**
	 * THREEJS REVISION
	 * @module THREE_REVISION
	 * @example PANOLENS.THREE_REVISION
	 * @type {string} threejs revision
	 */
	const THREE_REVISION = dependencies.three.split( '.' )[ 1 ];

	/**
	 * THREEJS VERSION
	 * @module THREE_VERSION
	 * @example PANOLENS.THREE_VERSION
	 * @type {string} threejs version
	 */
	const THREE_VERSION = dependencies.three.replace( /[^0-9.]/g, '' );

	/**
	 * CONTROLS
	 * @module CONTROLS
	 * @example PANOLENS.CONTROLS.ORBIT
	 * @property {number} ORBIT 0
	 * @property {number} DEVICEORIENTATION 1
	 */
	const CONTROLS = { ORBIT: 0, DEVICEORIENTATION: 1 };

	/**
	 * MODES
	 * @module MODES
	 * @example PANOLENS.MODES.UNKNOWN
	 * @property {number} UNKNOWN 0
	 * @property {number} NORMAL 1
	 * @property {number} CARDBOARD 2
	 * @property {number} STEREO 3
	 */
	const MODES = { UNKNOWN: 0, NORMAL: 1, CARDBOARD: 2, STEREO: 3 };

	/**
	 * Data URI Images
	 * @module DataImage
	 * @example PANOLENS.DataImage.Info
	 * @property {string} Info Information Icon
	 * @property {string} Arrow Arrow Icon
	 * @property {string} FullscreenEnter Fullscreen Enter Icon
	 * @property {string} FullscreenLeave Fullscreen Leave Icon
	 * @property {string} VideoPlay Video Play Icon
	 * @property {string} VideoPause Video Pause Icon
	 * @property {string} WhiteTile White Tile Icon
	 * @property {string} Setting Settings Icon
	 * @property {string} ChevronRight Chevron Right Icon
	 * @property {string} Check Check Icon
	 * @property {string} ViewIndicator View Indicator Icon
	 */
	const DataImage = {
	    Info: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC', 
		Next:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAElEQVR4nO3aOw6CUBRF0YMxsdMhOAYrrWxt/IzFUTgWEys7RyBOx9LmWKiN8RMeAZS7V2uAd3cCoiABAAAAANAY2z3bG9uDptdSu/vwe9+cQkV4Gt7hItje+bUYEWyvbF+I8D5CHiXCkghEIIIkyfaCCJ8jHIkQKMKcCN8j9FP3nZVY1FrSMHX7BFNJozef5ZJmWZadi+60TIBc0jh1+wokRehUtJgmTCQdip4ObQogJURoW4DC2hag8HWgTQGSLoLdEgfc3g9al0q+Bv9ClTdCPy/0rXDoH0PRh4/7rxDDBx4+7rMBho86vMTDUR6PS8FfkHhw5FdkAAAAAAA1uwKmQGnnMsAmQAAAAABJRU5ErkJggg',
		Next_disable:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAGVSURBVHhe7dpLToRAEAZgHmHpAdw53siBkHgOz+E1NLzGEznjag6gSwJYlRQLRTPSka4K/N8GalbUn2oaMgQAAAAAAACwQaEc1RVF8TQMw30URS95nu/l58WZCGBsXsrAZwjqAXxvfuQrhEiOan5qnvV9f1eW5UHKxagHkCTJm5xO+AjBxD2gaZpT27Y3Uk4suRzUJ4ClabqjSThJObHkJJjZBhlNwpEmYSflxBKTYCoA5jsEcwEwnyGYDID5CsFsAMxHCCZ2gd/Q7nBLu8NRyon/2B1MT8Coqqpz13XXUk7QJBxoElIpZ3EOgC7qnS7qSkp1riE4LwFLzTNaDntaDo2Uf2b6HjCXSwirCoBxCHVdP0p50eoCmGt1AfDNMMuyBykvWlUALjuBcwBxHH/IqQmu2+DmH4TMLwF6H3i90Dy/Dzg1zzb/MmQ2gE2/DvtqnpkLwGfzzFQAvptnZgKg5lX+GzARgFbzTD0AzeaZ+oOQZvNMPYAwDJ/l9AsfzTMT94BNfyAx0vpEBgAAAAAAALYnCD4BLWb8LzUbk5IAAAAASUVORK5CYII',
		Prev:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDUlEQVR4nO3aPW7CQBTE8XlR0iZ34gI04XxJn4pTBDoOkFOkhGJSwEoUmFj4Y2Hf/yfRIe+bsSUb1hIAAAAAALOyvbS9rD1HFafw+9MnVwln4Ys8JVwIf17CovZ8k7oS3ra3tt9qzzgZwneH3xC+VYTvDv9N+Fb1CP9ae8bJEP4Bw8cYB/HxOf5L0kvHVz4k/Y6xVk+fEbGbZaV/znwt733nfxoaXtfP/N27uYAWwksDr4AW3FxARKwlrSQdxhtnfoOugBZKeB56gIhY217pvm6DPzOudeQHfRAaFSUo+S/BghKU/N+gghJECZIoQVLyjZGCEpR8c7S4UEKe7fHCmV+QKJz5FRkAAAAAQEV/wVXsaBhdqfYAAAAASUVORK5CYII',
		Prev_disable:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAGWSURBVHhe7dpBSsNAFAbgJhAKOYIrXXsH1wqloMHkVh6kJLpIF7rtHVzryjuUQmp/eYUsqlObmZc39P+gdF67+n8yaRI6ISIiIiIiItK1XC5XeMk4ikTe1TVN87HZbC6xzrLssyiKq58vlI1SQD/83lglpPKu5lB4wGdt277JqEa1gN/C763X63dZqlHbAq7waZq+lGX5IKMalQKshofgBVgOD0ELsB4eghUQQ3gIUkAs4cH7z+AR4Z+thAevR8CR4QsZTfBWgCt8kiSvVVXdyWiGlwJc4bXleV7P5/NHGf80+BxgLTzsttqFLJ0GFWAx/H+dXAAeZMQeHlTvBi06uYDZbHaDhxgyRmvQEYAnOLGXMHgLWCyh67ovWTqd/YWQt5Og60jYbre3i8WikdEM73eDriPB0p0geC8AYiohSAEQSwnBCoAYSghaAFgvIXgBYLkElQLAaglqN0Ou64Td1dt9XddPMqpRKwBcJUyn02tZqlHbAn2HtgOKQUEyqhmlAOiXMFb40Vn4iwwRERERERGdn8nkG0xy/2BTQufhAAAAAElFTkSuQmCC',
		Close:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB7ElEQVR4nO2YPW4TURRGz01SoJAC9hCxAdYQYBlJh8QSKFhBuhTQOpQIBOugpKBLETkdDhUkTb40uYYotmf88959M/NOZctvNN85ki1rIAhJB5J+SjqRtB21IwRJryRd6R8fJW1F78rCDPnhRFgg3/8ILeT7G2EJ+f5FWEG+PxEkvVxRvvsR7uT/riHvnHYuwgbluxchgXx3IiSULz9CBvlyI2SULy+CpBeZ5cuJECjvjMIiFCDv5I+gcuSdfBFUnryTPoLKlXfSRVD58s5SEaytPPAVeLRqwMycAodmdtN0sDGApAPgG92Rd0bAUVOEhQE6LO80RpgboAfyzsIIMwP0SN6ZG+FBgB7KOzMj3AvQY3nnQYRpgAHIO/ciGICkp8A58DhwWE5em9kHAP/HtA0obk9WBPzxN/9/BZ4A+3Mueg68T7tro3wG3s35bGJmF/5mx1+Y2W/g+6wrJO1tdF56Ls3sR5uDZTxXC6QGiB4QTQ0QPSCaGiB6QDQ1QPSAaAYfYKf5yEa4Bo6BsxZnd4E3wLOki+7IFeCLmb1te1jSGPiUcM+UXF+BX4nPr8zgfwNqgOgB0dQA0QOiqQGiB0RTA0QPiKYGiB4QTQ0QPSCaGiB6QDSDD9D2idA1MF7jPpdLnl/3fpM1rh0Wty44AmmswvTCAAAAAElFTkSuQmCC',
		Vr_Disable:'data:image/png;base64,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',
		Vr_Enable:'data:image/png;base64,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',
		Locate:'data:image/png;base64,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',
		
		/*Locate:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMAUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALMw9IgAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAACXBIWXMAAA7CAAAOwgEVKEqAAAAEl0lEQVR4Xu3SAQEAAAjDIPuXvkEYGbiFVgBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFwBUAVwBcAXAFoG0PyxI7xUn501cAAAAASUVORK5CYII',
		Locate:'data:image/png;base64,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', 
		Locate:'data:image/png;base64,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',*/
	    Arrow: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=',
	    FullscreenEnter: 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=',
	    FullscreenLeave: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=',
	    VideoPlay: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==',
	    VideoPause: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==',
	    WhiteTile: 'data:image/png;base64,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',
	    Setting: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC',
	    ChevronRight: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+',
	    Check: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=',
	    ViewIndicator: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+'
	};

	/**
	 * @module ImageLoader
	 * @description Image loader with progress based on {@link https://github.com/mrdoob/three.js/blob/master/src/loaders/ImageLoader.js}
	 */
	const ImageLoader = {

	    /**
	     * Load image
	     * @example PANOLENS.ImageLoader.load( IMAGE_URL )
	     * @method load
	     * @param  {string}   url        - An image url
	     * @param  {function} onLoad     - On load callback
	     * @param  {function} onProgress - In progress callback
	     * @param  {function} onError    - On error callback
	     */
	    load: function ( url, onLoad = () => {}, onProgress = () => {}, onError = () => {} ) {

	        // Enable cache
	        THREE.Cache.enabled = true;
			//console.log("---------load------------"+url);

	        let cached, request, arrayBufferView, blob, urlCreator, image, reference;
		
	        // Reference key
	        for ( let iconName in DataImage ) {
		
	            if ( DataImage.hasOwnProperty( iconName ) && url === DataImage[ iconName ] ) {
		
	                reference = iconName;
		
	            }
		
	        }
		
	        // Cached
	        cached = THREE.Cache.get( reference ? reference : url );
		
	        if ( cached !== undefined ) {
		
	            if ( onLoad ) {
		
	                setTimeout( function () {
		
	                    onProgress( { loaded: 1, total: 1 } );
	                    onLoad( cached );
		
	                }, 0 );
		
	            }
		
	            return cached;
		
	        }
			
	        // Construct a new XMLHttpRequest
	        urlCreator = window.URL || window.webkitURL;
	        image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
		
	        // Add to cache
	        THREE.Cache.add( reference ? reference : url, image );
		
	        const onImageLoaded = () => {
		
	            urlCreator.revokeObjectURL( image.src );
	            onLoad( image );
		
	        };

	        if ( url.indexOf( 'data:' ) === 0 ) {

	            image.addEventListener( 'load', onImageLoaded, false );
	            image.src = url;
	            return image;
	        }
		
	        image.crossOrigin = this.crossOrigin !== undefined ? this.crossOrigin : '';
		
	        request = new window.XMLHttpRequest();
	        request.open( 'GET', url, true );
	        request.responseType = 'arraybuffer';
	        request.addEventListener( 'error', onError );
	        request.addEventListener( 'progress', event => {

	            if  ( !event ) return;

	            const { loaded, total, lengthComputable } = event;
	            
	            if ( lengthComputable ) {
		
	                onProgress( { loaded, total } );
		
	            }
		
	        } );
	        
	        request.addEventListener( 'loadend', event => {

	            if  ( !event ) return;
	            const { currentTarget: { response } } = event;

	            arrayBufferView = new Uint8Array( response );
	            blob = new window.Blob( [ arrayBufferView ] );
					
	            image.addEventListener( 'load', onImageLoaded, false );
	            image.src = urlCreator.createObjectURL( blob );
		
	        } );
		
	        request.send(null);
		
	    }

	};

	/**
	 * @module TextureLoader
	 * @description Texture loader based on {@link https://github.com/mrdoob/three.js/blob/master/src/loaders/TextureLoader.js}
	 */
	const TextureLoader = {

	    /**
	     * Load image texture
	     * @example PANOLENS.TextureLoader.load( IMAGE_URL )
	     * @method load
	     * @param  {string}   url        - An image url
	     * @param  {function} onLoad     - On load callback
	     * @param  {function} onProgress - In progress callback
	     * @param  {function} onError    - On error callback
	     * @return {THREE.Texture}   	 - Image texture
	     */
	    load: function ( url, onLoad = () => {}, onProgress, onError ) {

	        var texture = new THREE.Texture(); 

	        ImageLoader.load( url, function ( image ) {

	            texture.image = image;

	            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
	            const isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

	            texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
	            texture.needsUpdate = true;

	            onLoad( texture );

	        }, onProgress, onError );

	        return texture;

	    }

	};

	/**
	 * @module CubeTextureLoader
	 * @description Cube Texture Loader based on {@link https://github.com/mrdoob/three.js/blob/master/src/loaders/CubeTextureLoader.js}
	 */
	const CubeTextureLoader = {

	    /**
	     * Load 6 images as a cube texture
	     * @example PANOLENS.CubeTextureLoader.load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] )
	     * @method load
	     * @param  {array}   urls        - array of 6 urls to images, one for each side of the CubeTexture. The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z
	     * @param  {function} onLoad     - On load callback
	     * @param  {function} onProgress - In progress callback
	     * @param  {function} onError    - On error callback
	     * @return {THREE.CubeTexture}   - Cube texture
	     */
	    load: function ( urls, onLoad = () => {}, onProgress = () => {}, onError ) {

		   var texture, loaded, progress, all, loadings;

		   texture = new THREE.CubeTexture( [] );

		   loaded = 0;
		   progress = {};
		   all = {};

		   urls.map( function ( url, index ) {

			   ImageLoader.load( url, function ( image ) {

				   texture.images[ index ] = image;

				   loaded++;

				   if ( loaded === 6 ) {

					   texture.needsUpdate = true;

					   onLoad( texture );

				   }

			   }, function ( event ) {

				   progress[ index ] = { loaded: event.loaded, total: event.total };

				   all.loaded = 0;
				   all.total = 0;
				   loadings = 0;

				   for ( var i in progress ) {

					   loadings++;
					   all.loaded += progress[ i ].loaded;
					   all.total += progress[ i ].total;

				   }

				   if ( loadings < 6 ) {

					   all.total = all.total / loadings * 6;

				   }

				   onProgress( all );

			   }, onError );

		   } );

		   return texture;

	    }

	};

	/**
	 * @classdesc User Media
	 * @constructor
	 * @param {object} [constraints={ video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: { exact: 'environment' } }, audio: false }]
	 */
	function Media ( constraints ) {

	    const defaultConstraints = { video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: { exact: 'environment' } }, audio: false };

	    this.constraints = Object.assign( defaultConstraints, constraints );

	    this.container = null;
	    this.scene = null;
	    this.element = null;
	    this.devices = [];
	    this.stream = null;
	    this.ratioScalar = 1;
	    this.videoDeviceIndex = 0;

	}
	Media.prototype = Object.assign( Object.create( THREE.EventDispatcher.prototype ), {

	    setContainer: function ( container ) {

	        this.container = container;

	    },

	    setScene: function ( scene ) {

	        this.scene = scene;

	    },

	    /**
	     * Enumerate devices
	     * @memberOf Media
	     * @instance
	     * @returns {Promise}
	     */
	    enumerateDevices: function () {

	        const devices = this.devices;
	        const resolvedPromise = new Promise( resolve => { resolve( devices ); } );

	        return devices.length > 0 ? resolvedPromise : window.navigator.mediaDevices.enumerateDevices();

	    },

	    /**
	     * Switch to next available video device
	     * @memberOf Media
	     * @instance
	     */
	    switchNextVideoDevice: function () {

	        const stop = this.stop.bind( this );
	        const start = this.start.bind( this );
	        const setVideDeviceIndex = this.setVideDeviceIndex.bind( this );

	        let index = this.videoDeviceIndex;

	        this.getDevices( 'video' )
	            .then( devices => {
	                stop();
	                index++;
	                if ( index >= devices.length ) {
	                    setVideDeviceIndex( 0 );
	                    index--;
	                } else {
	                    setVideDeviceIndex( index );
	                }

	                start( devices[ index ] );
	            

	            } );

	    },

	    /**
	     * Get devices
	     * @param {string} type - type keyword to match device.kind
	     * @memberOf Media
	     * @instance
	     */
	    getDevices: function ( type = 'video' ) {

	        const devices = this.devices;
	        const validate = _devices => {

	            return _devices.map( device => { 
	                
	                if ( !devices.includes( device ) ) { devices.push( device ); }
	                return device; 
	            
	            } );
	            
	        };
	        const filter = _devices => {

	            const reg = new RegExp( type, 'i' );
	            return _devices.filter( device => reg.test( device.kind ) );

	        };

	        return this.enumerateDevices()
	            .then( validate )
	            .then( filter );

	    },

	    /**
	     * Get user media
	     * @param {MediaStreamConstraints} constraints
	     * @memberOf Media
	     * @instance
	     */
	    getUserMedia: function ( constraints ) {

	        const setMediaStream = this.setMediaStream.bind( this );
	        const playVideo = this.playVideo.bind( this );
	        const onCatchError = error => { console.warn( `PANOLENS.Media: ${error}` ); };

	        return window.navigator.mediaDevices.getUserMedia( constraints )
	            .then( setMediaStream )
	            .then( playVideo )
	            .catch( onCatchError );

	    },

	    /**
	     * Set video device index
	     * @param {number} index 
	     * @memberOf Media
	     * @instance
	     */
	    setVideDeviceIndex: function ( index ) {

	        this.videoDeviceIndex = index;

	    },

	    /**
	     * Start streaming
	     * @param {MediaDeviceInfo} [targetDevice]
	     * @memberOf Media
	     * @instance
	     */
	    start: function( targetDevice ) {

	        const constraints = this.constraints;
	        const getUserMedia = this.getUserMedia.bind( this );
	        const onVideoDevices = devices => {

	            if ( !devices || devices.length === 0 ) {

	                throw Error( 'no video device found' );

	            }

	            const device = targetDevice || devices[ 0 ];
	            constraints.video.deviceId = device.deviceId;

	            return getUserMedia( constraints );

	        };

	        this.element = this.createVideoElement();

	        return this.getDevices().then( onVideoDevices );

	    },

	    /**
	     * Stop streaming
	     * @memberOf Media
	     * @instance
	     */
	    stop: function () {

	        const stream = this.stream;

	        if ( stream && stream.active ) {

	            const track = stream.getTracks()[ 0 ];

	            track.stop();

	            window.removeEventListener( 'resize', this.onWindowResize.bind( this ) );

	            this.element = null;
	            this.stream = null;

	        }

	    },

	    /**
	     * Set media stream
	     * @param {MediaStream} stream 
	     * @memberOf Media
	     * @instance
	     */
	    setMediaStream: function ( stream ) {

	        this.stream = stream;
	        this.element.srcObject = stream;

	        if ( this.scene ) {

	            this.scene.background = this.createVideoTexture();

	        }
	        
	        window.addEventListener( 'resize', this.onWindowResize.bind( this ) );

	    },

	    /**
	     * Play video element
	     * @memberOf Media
	     * @instance
	     */
	    playVideo: function () {

	        const { element } = this;

	        if ( element ) {

	            element.play();
	            this.dispatchEvent( { type: 'play' } );

	        }

	    },

	    /**
	     * Pause video element
	     * @memberOf Media
	     * @instance
	     */
	    pauseVideo: function () {

	        const { element } = this;

	        if ( element ) {

	            element.pause();
	            this.dispatchEvent( { type: 'pause' } );

	        }

	    },

	    /**
	     * Create video texture
	     * @memberOf Media
	     * @instance
	     * @returns {THREE.VideoTexture}
	     */
	    createVideoTexture: function () {

	        const video = this.element;
	        const texture = new THREE.VideoTexture( video );

	        texture.generateMipmaps = false;
	        texture.minFilter = THREE.LinearFilter;
	        texture.magFilter = THREE.LinearFilter;
	        texture.format = THREE.RGBFormat;
	        texture.center.set( 0.5, 0.5 );

	        video.addEventListener( 'canplay', this.onWindowResize.bind( this ) );

	        return texture;

	    },

	    /**
	     * Create video element
	     * @memberOf Media
	     * @instance
	     * @returns {HTMLVideoElement}
	     * @fires Media#canplay
	     */
	    createVideoElement: function() {

	        const dispatchEvent = this.dispatchEvent.bind( this );
	        const video = document.createElement( 'video' );

	        /**
	         * Video can play event
	         * @type {object}
	         * @event Media#canplay
	         */
	        const canPlay = () => dispatchEvent( { type: 'canplay' } );
	        
	        video.setAttribute( 'autoplay', '' );
	        video.setAttribute( 'muted', '' );
	        video.setAttribute( 'playsinline', '' );

	        video.style.position = 'absolute';
	        video.style.top = '0';
	        video.style.left = '0';
	        video.style.width = '100%';
	        video.style.height = '100%';
	        video.style.objectPosition = 'center';
	        video.style.objectFit = 'cover';
	        video.style.display = this.scene ? 'none' : '';

	        video.addEventListener( 'canplay', canPlay );

	        return video;

	    },

	    /**
	     * On window resize event
	     * @param {Event} event 
	     * @memberOf Media
	     * @instance
	     */
	    onWindowResize: function () {

	        if ( this.element && this.element.videoWidth && this.element.videoHeight && this.scene ) {

	            const { clientWidth: width, clientHeight: height } = this.container;
	            const texture = this.scene.background;
	            const { videoWidth, videoHeight } = this.element;
	            const cameraRatio = videoHeight / videoWidth;
	            const viewportRatio = this.container ? width / height : 1.0;
	            const ratio = cameraRatio * viewportRatio * this.ratioScalar;

	            if ( width > height ) {
	                texture.repeat.set( ratio, 1 );
	            } else {
	                texture.repeat.set( 1, 1 / ratio );
	            }

	        }

	    }

	} );

	/**
	 * @classdesc Reticle 3D Sprite
	 * @constructor
	 * @param {THREE.Color} [color=0xffffff] - Color of the reticle sprite
	 * @param {boolean} [autoSelect=true] - Auto selection
	 * @param {number} [dwellTime=1500] - Duration for dwelling sequence to complete
	 */

	function Reticle ( color = 0xffffff, autoSelect = true, dwellTime = 1500 ) {
 
		//color = #00ffff;
		color = 0x00ffff;
	    this.dpr = 2;//window.devicePixelRatio;

	    const { canvas, context } = this.createCanvas();
	    const material = new THREE.SpriteMaterial( { color, map: this.createCanvasTexture( canvas ) } );

	    THREE.Sprite.call( this, material );

	    this.canvasWidth = canvas.width;
	    this.canvasHeight = canvas.height;
	    this.context = context;
	    this.color = color instanceof THREE.Color ? color : new THREE.Color( color );    

	    this.autoSelect = autoSelect;
	    this.dwellTime = dwellTime;
	    this.rippleDuration = 500;
	    this.position.z = -10;
	    this.center.set( 0.5, 0.5 );
	    this.scale.set( 0.5, 0.5, 1 );

	    this.startTimestamp = null;
	    this.timerId = null;
	    this.callback = null;

	    this.frustumCulled = false;

	    this.updateCanvasArcByProgress( 0 );

	}
	Reticle.prototype = Object.assign( Object.create( THREE.Sprite.prototype ), {

	    constructor: Reticle,

	    /**
	     * Set material color
	     * @param {THREE.Color} color 
	     * @memberOf Reticle
	     * @instance
	     */
	    setColor: function ( color ) {

	        this.material.color.copy( color instanceof THREE.Color ? color : new THREE.Color( color ) );

	    },

	    /**
	     * Create canvas texture
	     * @param {HTMLCanvasElement} canvas 
	     * @memberOf Reticle
	     * @instance
	     * @returns {THREE.CanvasTexture}
	     */
	    createCanvasTexture: function ( canvas ) {

	        const texture = new THREE.CanvasTexture( canvas );
	        texture.minFilter = THREE.LinearFilter;
	        texture.magFilter = THREE.LinearFilter;
	        texture.generateMipmaps = false;

	        return texture;

	    },

	    /**
	     * Create canvas element
	     * @memberOf Reticle
	     * @instance
	     * @returns {object} object
	     * @returns {HTMLCanvasElement} object.canvas
	     * @returns {CanvasRenderingContext2D} object.context
	     */
	    createCanvas: function () {

	        const width = 100;
	        const height = 100;
	        const canvas = document.createElement( 'canvas' );
	        const context = canvas.getContext( '2d' );
	        const dpr = this.dpr;

	        canvas.width = width * dpr;
	        canvas.height = height * dpr;
	        context.scale( dpr, dpr );

	        context.shadowBlur = 5;
	        context.shadowColor = 'rgba(200,200,200,0.9)';

	        return { canvas, context };

	    },

	    /**
	     * Update canvas arc by progress
	     * @param {number} progress 
	     * @memberOf Reticle
	     * @instance
	     */
	    updateCanvasArcByProgress: function ( progress ) {

	        const context = this.context;
	        const { canvasWidth, canvasHeight, material } = this;
	        const dpr = this.dpr;
	        const degree = progress * Math.PI * 2;
	        const color = this.color.getStyle();
	        const x = canvasWidth * 0.5 / dpr;
	        const y = canvasHeight * 0.5 / dpr;
	        const lineWidth = 15;
	        
	        context.clearRect( 0, 0, canvasWidth, canvasHeight );
	        context.beginPath();

	        if ( progress === 0 ) {
	            context.arc( x, y, canvasWidth / 16, 0, 2 * Math.PI );
	            context.fillStyle = color;
	            context.fill();
	        } else {
	            context.arc( x, y, canvasWidth / 4 - lineWidth, -Math.PI / 2, -Math.PI / 2 + degree );
	            context.strokeStyle = color;
	            context.lineWidth = lineWidth;
	            context.stroke();
	        }

	        context.closePath();

	        material.map.needsUpdate = true;

	    },

	    /**
	     * Ripple effect
	     * @memberOf Reticle
	     * @instance
	     * @fires Reticle#reticle-ripple-start
	     * @fires Reticle#reticle-ripple-end
	     */
	    ripple: function () {

	        const context = this.context;
	        const { canvasWidth, canvasHeight, material } = this;
	        const duration = this.rippleDuration;
	        const timestamp = performance.now();
	        const color = this.color;
	        const dpr = this.dpr;
	        const x = canvasWidth * 0.5 / dpr;
	        const y = canvasHeight * 0.5 / dpr;

	        const update = () => {

	            const timerId = window.requestAnimationFrame( update );
	            const elapsed = performance.now() - timestamp;
	            const progress = elapsed / duration;
	            const opacity = 1.0 - progress > 0 ? 1.0 - progress : 0;
	            const radius = progress * canvasWidth * 0.5 / dpr;

	            context.clearRect( 0, 0, canvasWidth, canvasHeight );
	            context.beginPath();
	            context.arc( x, y, radius, 0, Math.PI * 2 );
	            context.fillStyle = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, ${opacity})`;
	            context.fill();
	            context.closePath();

	            if ( progress >= 1.0 ) {

	                window.cancelAnimationFrame( timerId );
	                this.updateCanvasArcByProgress( 0 );

	                /**
	                 * Reticle ripple end event
	                 * @type {object}
	                 * @event Reticle#reticle-ripple-end
	                 */
	                this.dispatchEvent( { type: 'reticle-ripple-end' } );

	            }

	            material.map.needsUpdate = true;

	        };

	        /**
	         * Reticle ripple start event
	         * @type {object}
	         * @event Reticle#reticle-ripple-start
	         */
	        this.dispatchEvent( { type: 'reticle-ripple-start' } );

	        update();

	    },

	    /**
	     * Make reticle visible
	     * @memberOf Reticle
	     * @instance
	     */
	    show: function () {

	        this.visible = true;

	    },

	    /**
	     * Make reticle invisible
	     * @memberOf Reticle
	     * @instance
	     */
	    hide: function () {

	        this.visible = false;

	    },

	    /**
	     * Start dwelling
	     * @param {function} callback 
	     * @memberOf Reticle
	     * @instance
	     * @fires Reticle#reticle-start
	     */
	    start: function ( callback ) {

	        if ( !this.autoSelect ) {

	            return;

	        }

	        /**
	         * Reticle start event
	         * @type {object}
	         * @event Reticle#reticle-start
	         */
	        this.dispatchEvent( { type: 'reticle-start' } );

	        this.startTimestamp = performance.now();
	        this.callback = callback;
	        this.update();

	    },

	    /**
	     * End dwelling
	     * @memberOf Reticle
	     * @instance
	     * @fires Reticle#reticle-end
	     */
	    end: function(){

	        if ( !this.startTimestamp ) { return; }

	        window.cancelAnimationFrame( this.timerId );

	        this.updateCanvasArcByProgress( 0 );
	        this.callback = null;
	        this.timerId = null;
	        this.startTimestamp = null;

	        /**
	         * Reticle end event
	         * @type {object}
	         * @event Reticle#reticle-end
	         */
	        this.dispatchEvent( { type: 'reticle-end' } );

	    },

	    /**
	     * Update dwelling
	     * @memberOf Reticle
	     * @instance
	     * @fires Reticle#reticle-update
	     */
	    update: function () {

	        this.timerId = window.requestAnimationFrame( this.update.bind( this ) );

	        const elapsed = performance.now() - this.startTimestamp;
	        const progress = elapsed / this.dwellTime;

	        this.updateCanvasArcByProgress( progress );

	        /**
	         * Reticle update event
	         * @type {object}
	         * @event Reticle#reticle-update
	         */
	        this.dispatchEvent( { type: 'reticle-update', progress } );

	        if ( progress >= 1.0 ) {

	            window.cancelAnimationFrame( this.timerId );
	            if ( this.callback ) { this.callback(); }
	            this.end();
	            this.ripple();

	        }

	    }

	} );

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var Tween = createCommonjsModule(function (module, exports) {
	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */


	var _Group = function () {
		this._tweens = {};
		this._tweensAddedDuringUpdate = {};
	};

	_Group.prototype = {
		getAll: function () {

			return Object.keys(this._tweens).map(function (tweenId) {
				return this._tweens[tweenId];
			}.bind(this));

		},

		removeAll: function () {

			this._tweens = {};

		},

		add: function (tween) {

			this._tweens[tween.getId()] = tween;
			this._tweensAddedDuringUpdate[tween.getId()] = tween;

		},

		remove: function (tween) {

			delete this._tweens[tween.getId()];
			delete this._tweensAddedDuringUpdate[tween.getId()];

		},

		update: function (time, preserve) {

			var tweenIds = Object.keys(this._tweens);

			if (tweenIds.length === 0) {
				return false;
			}

			time = time !== undefined ? time : TWEEN.now();

			// Tweens are updated in "batches". If you add a new tween during an update, then the
			// new tween will be updated in the next batch.
			// If you remove a tween during an update, it may or may not be updated. However,
			// if the removed tween was added during the current batch, then it will not be updated.
			while (tweenIds.length > 0) {
				this._tweensAddedDuringUpdate = {};

				for (var i = 0; i < tweenIds.length; i++) {

					var tween = this._tweens[tweenIds[i]];

					if (tween && tween.update(time) === false) {
						tween._isPlaying = false;

						if (!preserve) {
							delete this._tweens[tweenIds[i]];
						}
					}
				}

				tweenIds = Object.keys(this._tweensAddedDuringUpdate);
			}

			return true;

		}
	};

	var TWEEN = new _Group();

	TWEEN.Group = _Group;
	TWEEN._nextId = 0;
	TWEEN.nextId = function () {
		return TWEEN._nextId++;
	};


	// Include a performance.now polyfill.
	// In node.js, use process.hrtime.
	if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
		TWEEN.now = function () {
			var time = process.hrtime();

			// Convert [seconds, nanoseconds] to milliseconds.
			return time[0] * 1000 + time[1] / 1000000;
		};
	}
	// In a browser, use self.performance.now if it is available.
	else if (typeof (self) !== 'undefined' &&
	         self.performance !== undefined &&
			 self.performance.now !== undefined) {
		// This must be bound, because directly assigning this function
		// leads to an invocation exception in Chrome.
		TWEEN.now = self.performance.now.bind(self.performance);
	}
	// Use Date.now if it is available.
	else if (Date.now !== undefined) {
		TWEEN.now = Date.now;
	}
	// Otherwise, use 'new Date().getTime()'.
	else {
		TWEEN.now = function () {
			return new Date().getTime();
		};
	}


	TWEEN.Tween = function (object, group) {
		this._object = object;
		this._valuesStart = {};
		this._valuesEnd = {};
		this._valuesStartRepeat = {};
		this._duration = 1000;
		this._repeat = 0;
		this._repeatDelayTime = undefined;
		this._yoyo = false;
		this._isPlaying = false;
		this._reversed = false;
		this._delayTime = 0;
		this._startTime = null;
		this._easingFunction = TWEEN.Easing.Linear.None;
		this._interpolationFunction = TWEEN.Interpolation.Linear;
		this._chainedTweens = [];
		this._onStartCallback = null;
		this._onStartCallbackFired = false;
		this._onUpdateCallback = null;
		this._onRepeatCallback = null;
		this._onCompleteCallback = null;
		this._onStopCallback = null;
		this._group = group || TWEEN;
		this._id = TWEEN.nextId();

	};

	TWEEN.Tween.prototype = {
		getId: function () {
			return this._id;
		},

		isPlaying: function () {
			return this._isPlaying;
		},

		to: function (properties, duration) {

			this._valuesEnd = Object.create(properties);

			if (duration !== undefined) {
				this._duration = duration;
			}

			return this;

		},

		duration: function duration(d) {
			this._duration = d;
			return this;
		},

		start: function (time) {

			this._group.add(this);

			this._isPlaying = true;

			this._onStartCallbackFired = false;

			this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
			this._startTime += this._delayTime;

			for (var property in this._valuesEnd) {

				// Check if an Array was provided as property value
				if (this._valuesEnd[property] instanceof Array) {

					if (this._valuesEnd[property].length === 0) {
						continue;
					}

					// Create a local copy of the Array with the start value at the front
					this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);

				}

				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (this._object[property] === undefined) {
					continue;
				}

				// Save the starting value.
				this._valuesStart[property] = this._object[property];

				if ((this._valuesStart[property] instanceof Array) === false) {
					this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}

				this._valuesStartRepeat[property] = this._valuesStart[property] || 0;

			}

			return this;

		},

		stop: function () {

			if (!this._isPlaying) {
				return this;
			}

			this._group.remove(this);
			this._isPlaying = false;

			if (this._onStopCallback !== null) {
				this._onStopCallback(this._object);
			}

			this.stopChainedTweens();
			return this;

		},

		end: function () {

			this.update(Infinity);
			return this;

		},

		stopChainedTweens: function () {

			for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
				this._chainedTweens[i].stop();
			}

		},

		group: function (group) {
			this._group = group;
			return this;
		},

		delay: function (amount) {

			this._delayTime = amount;
			return this;

		},

		repeat: function (times) {

			this._repeat = times;
			return this;

		},

		repeatDelay: function (amount) {

			this._repeatDelayTime = amount;
			return this;

		},

		yoyo: function (yoyo) {

			this._yoyo = yoyo;
			return this;

		},

		easing: function (easingFunction) {

			this._easingFunction = easingFunction;
			return this;

		},

		interpolation: function (interpolationFunction) {

			this._interpolationFunction = interpolationFunction;
			return this;

		},

		chain: function () {

			this._chainedTweens = arguments;
			return this;

		},

		onStart: function (callback) {

			this._onStartCallback = callback;
			return this;

		},

		onUpdate: function (callback) {

			this._onUpdateCallback = callback;
			return this;

		},

		onRepeat: function onRepeat(callback) {

			this._onRepeatCallback = callback;
			return this;

		},

		onComplete: function (callback) {

			this._onCompleteCallback = callback;
			return this;

		},

		onStop: function (callback) {

			this._onStopCallback = callback;
			return this;

		},

		update: function (time) {

			var property;
			var elapsed;
			var value;

			if (time < this._startTime) {
				return true;
			}

			if (this._onStartCallbackFired === false) {

				if (this._onStartCallback !== null) {
					this._onStartCallback(this._object);
				}

				this._onStartCallbackFired = true;
			}

			elapsed = (time - this._startTime) / this._duration;
			elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;

			value = this._easingFunction(elapsed);

			for (property in this._valuesEnd) {

				// Don't update properties that do not exist in the source object
				if (this._valuesStart[property] === undefined) {
					continue;
				}

				var start = this._valuesStart[property] || 0;
				var end = this._valuesEnd[property];

				if (end instanceof Array) {

					this._object[property] = this._interpolationFunction(end, value);

				} else {

					// Parses relative end values with start as base (e.g.: +10, -3)
					if (typeof (end) === 'string') {

						if (end.charAt(0) === '+' || end.charAt(0) === '-') {
							end = start + parseFloat(end);
						} else {
							end = parseFloat(end);
						}
					}

					// Protect against non numeric properties.
					if (typeof (end) === 'number') {
						this._object[property] = start + (end - start) * value;
					}

				}

			}

			if (this._onUpdateCallback !== null) {
				this._onUpdateCallback(this._object, elapsed);
			}

			if (elapsed === 1) {

				if (this._repeat > 0) {

					if (isFinite(this._repeat)) {
						this._repeat--;
					}

					// Reassign starting values, restart by making startTime = now
					for (property in this._valuesStartRepeat) {

						if (typeof (this._valuesEnd[property]) === 'string') {
							this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
						}

						if (this._yoyo) {
							var tmp = this._valuesStartRepeat[property];

							this._valuesStartRepeat[property] = this._valuesEnd[property];
							this._valuesEnd[property] = tmp;
						}

						this._valuesStart[property] = this._valuesStartRepeat[property];

					}

					if (this._yoyo) {
						this._reversed = !this._reversed;
					}

					if (this._repeatDelayTime !== undefined) {
						this._startTime = time + this._repeatDelayTime;
					} else {
						this._startTime = time + this._delayTime;
					}

					if (this._onRepeatCallback !== null) {
						this._onRepeatCallback(this._object);
					}

					return true;

				} else {

					if (this._onCompleteCallback !== null) {

						this._onCompleteCallback(this._object);
					}

					for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						this._chainedTweens[i].start(this._startTime + this._duration);
					}

					return false;

				}

			}

			return true;

		}
	};


	TWEEN.Easing = {

		Linear: {

			None: function (k) {

				return k;

			}

		},

		Quadratic: {

			In: function (k) {

				return k * k;

			},

			Out: function (k) {

				return k * (2 - k);

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}

				return - 0.5 * (--k * (k - 2) - 1);

			}

		},

		Cubic: {

			In: function (k) {

				return k * k * k;

			},

			Out: function (k) {

				return --k * k * k + 1;

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k + 2);

			}

		},

		Quartic: {

			In: function (k) {

				return k * k * k * k;

			},

			Out: function (k) {

				return 1 - (--k * k * k * k);

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}

				return - 0.5 * ((k -= 2) * k * k * k - 2);

			}

		},

		Quintic: {

			In: function (k) {

				return k * k * k * k * k;

			},

			Out: function (k) {

				return --k * k * k * k * k + 1;

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k * k * k + 2);

			}

		},

		Sinusoidal: {

			In: function (k) {

				return 1 - Math.cos(k * Math.PI / 2);

			},

			Out: function (k) {

				return Math.sin(k * Math.PI / 2);

			},

			InOut: function (k) {

				return 0.5 * (1 - Math.cos(Math.PI * k));

			}

		},

		Exponential: {

			In: function (k) {

				return k === 0 ? 0 : Math.pow(1024, k - 1);

			},

			Out: function (k) {

				return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

			},

			InOut: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}

				return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

			}

		},

		Circular: {

			In: function (k) {

				return 1 - Math.sqrt(1 - k * k);

			},

			Out: function (k) {

				return Math.sqrt(1 - (--k * k));

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return - 0.5 * (Math.sqrt(1 - k * k) - 1);
				}

				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

			}

		},

		Elastic: {

			In: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

			},

			Out: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

			},

			InOut: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				k *= 2;

				if (k < 1) {
					return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
				}

				return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

			}

		},

		Back: {

			In: function (k) {

				var s = 1.70158;

				return k * k * ((s + 1) * k - s);

			},

			Out: function (k) {

				var s = 1.70158;

				return --k * k * ((s + 1) * k + s) + 1;

			},

			InOut: function (k) {

				var s = 1.70158 * 1.525;

				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}

				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

			}

		},

		Bounce: {

			In: function (k) {

				return 1 - TWEEN.Easing.Bounce.Out(1 - k);

			},

			Out: function (k) {

				if (k < (1 / 2.75)) {
					return 7.5625 * k * k;
				} else if (k < (2 / 2.75)) {
					return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
				} else if (k < (2.5 / 2.75)) {
					return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
				} else {
					return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
				}

			},

			InOut: function (k) {

				if (k < 0.5) {
					return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				}

				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

			}

		}

	};

	TWEEN.Interpolation = {

		Linear: function (v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.Linear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

		},

		Bezier: function (v, k) {

			var b = 0;
			var n = v.length - 1;
			var pw = Math.pow;
			var bn = TWEEN.Interpolation.Utils.Bernstein;

			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}

			return b;

		},

		CatmullRom: function (v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.CatmullRom;

			if (v[0] === v[m]) {

				if (k < 0) {
					i = Math.floor(f = m * (1 + k));
				}

				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

			} else {

				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
				}

				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
				}

				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

			}

		},

		Utils: {

			Linear: function (p0, p1, t) {

				return (p1 - p0) * t + p0;

			},

			Bernstein: function (n, i) {

				var fc = TWEEN.Interpolation.Utils.Factorial;

				return fc(n) / fc(i) / fc(n - i);

			},

			Factorial: (function () {

				var a = [1];

				return function (n) {

					var s = 1;

					if (a[n]) {
						return a[n];
					}

					for (var i = n; i > 1; i--) {
						s *= i;
					}

					a[n] = s;
					return s;

				};

			})(),

			CatmullRom: function (p0, p1, p2, p3, t) {

				var v0 = (p2 - p0) * 0.5;
				var v1 = (p3 - p1) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;

				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

			}

		}

	};

	// UMD (Universal Module Definition)
	(function (root) {

		{

			// Node.js
			module.exports = TWEEN;

		}

	})();
	});

	/**
	 * @classdesc Information spot attached to panorama
	 * @constructor
	 * @param {number} [scale=300] - Default scale
	 * @param {string} [imageSrc=PANOLENS.DataImage.Info] - Image overlay info
	 * @param {boolean} [animated=true] - Enable default hover animation
	 */
	function Infospot ( scale = 300, imageSrc, animated ) {
		
	    const duration = 500, scaleFactor = 1.3;

	    imageSrc = imageSrc || DataImage.Info;
		
		//console.log("imageSrc : "+imageSrc);

	    THREE.Sprite.call( this );

	    this.type = 'infospot';

	    this.animated = animated !== undefined ? animated : true;
	    this.isHovering = false;

	    /*
	     * TODO: Three.js bug hotfix for sprite raycasting r104
	     * https://github.com/mrdoob/three.js/issues/14624
	     */
	    this.frustumCulled = false;

	    this.element = null;
	    this.toPanorama = null;
	    this.cursorStyle = null;

	    this.mode = MODES.NORMAL;

	    this.scale.set( scale, scale, 1 );
	    this.rotation.y = Math.PI;

	    this.container = null;

	    this.originalRaycast = this.raycast;

	    // Event Handler
	    this.HANDLER_FOCUS = null;	

	    this.material.side = THREE.DoubleSide;
	    this.material.depthTest = false;
	    this.material.transparent = true;
	    this.material.opacity = 0;

	    this.scaleUpAnimation = new Tween.Tween();
	    this.scaleDownAnimation = new Tween.Tween();


	    const postLoad = function ( texture ) {

	        if ( !this.material ) { return; }

	        const ratio = texture.image.width / texture.image.height;
	        const textureScale = new THREE.Vector3();

	        texture.image.width = texture.image.naturalWidth || 64;
	        texture.image.height = texture.image.naturalHeight || 64;

	        this.scale.set( ratio * scale, scale, 1 );

	        textureScale.copy( this.scale );

	        this.scaleUpAnimation = new Tween.Tween( this.scale )
	            .to( { x: textureScale.x * scaleFactor, y: textureScale.y * scaleFactor }, duration )
	            .easing( Tween.Easing.Elastic.Out );

	        this.scaleDownAnimation = new Tween.Tween( this.scale )
	            .to( { x: textureScale.x, y: textureScale.y }, duration )
	            .easing( Tween.Easing.Elastic.Out );

	        this.material.map = texture;
	        this.material.needsUpdate = true;

	    }.bind( this );

	    // Add show and hide animations
	    this.showAnimation = new Tween.Tween( this.material )
	        .to( { opacity: 1 }, duration )
	        .onStart( this.enableRaycast.bind( this, true ) )
	        .easing( Tween.Easing.Quartic.Out );

	    this.hideAnimation = new Tween.Tween( this.material )
	        .to( { opacity: 0 }, duration )
	        .onStart( this.enableRaycast.bind( this, false ) )
	        .easing( Tween.Easing.Quartic.Out );

	    // Attach event listeners
	    this.addEventListener( 'click', this.onClick );
	    this.addEventListener( 'hover', this.onHover );
	    this.addEventListener( 'hoverenter', this.onHoverStart );
	    this.addEventListener( 'hoverleave', this.onHoverEnd );
	    this.addEventListener( 'panolens-dual-eye-effect', this.onDualEyeEffect );
	    this.addEventListener( 'panolens-container', this.setContainer.bind( this ) );
	    this.addEventListener( 'dismiss', this.onDismiss );
	    this.addEventListener( 'panolens-infospot-focus', this.setFocusMethod );

	    TextureLoader.load( imageSrc, postLoad );	

	}
	Infospot.prototype = Object.assign( Object.create( THREE.Sprite.prototype ), {

	    constructor: Infospot,

	    /**
	     * Set infospot container
	     * @param {HTMLElement|object} data - Data with container information
	     * @memberOf Infospot
	     * @instance
	     */
	    setContainer: function ( data ) {

	        let container;
		
	        if ( data instanceof HTMLElement ) {
		
	            container = data;
		
	        } else if ( data && data.container ) {
		
	            container = data.container;
		
	        }
		
	        // Append element if exists
	        if ( container && this.element ) {
		
	            container.appendChild( this.element );
		
	        }
		
	        this.container = container;
		
	    },

	    /**
	     * Get container
	     * @memberOf Infospot
	     * @instance
	     * @return {HTMLElement} - The container of this infospot
	     */
	    getContainer: function () {

	        return this.container;

	    },

	    /**
	     * This will be called by a click event
	     * Translate and lock the hovering element if any
	     * @param  {object} event - Event containing mouseEvent with clientX and clientY
	     * @memberOf Infospot
	     * @instance
	     */
	    onClick: function ( event ) {

	        if ( this.element && this.getContainer() ) {

	            this.onHoverStart( event );
	            // Lock element
	            this.lockHoverElement();

	        }

	    },

	    /**
	     * Dismiss current element if any
	     * @param  {object} event - Dismiss event
	     * @memberOf Infospot
	     * @instance
	     */
	    onDismiss: function () {

	        if ( this.element ) {

	            this.unlockHoverElement();
	            this.onHoverEnd();

	        }

	    },

	    /**
	     * This will be called by a mouse hover event
	     * Translate the hovering element if any
	     * @param  {object} event - Event containing mouseEvent with clientX and clientY
	     * @memberOf Infospot
	     * @instance
	     */
	    onHover: function () {},

	    /**
	     * This will be called on a mouse hover start
	     * Sets cursor style to 'pointer', display the element and scale up the infospot
	     * @param {object} event
	     * @memberOf Infospot
	     * @instance
	     */
	    onHoverStart: function ( event ) {
			//console.log("---------onHoverStart-------------");
			
	        if ( !this.getContainer() ) { return; }
	        const cursorStyle = this.cursorStyle || ( this.mode === MODES.NORMAL ? 'pointer' : 'default' );
	        const { scaleDownAnimation, scaleUpAnimation, element } = this;
			//console.log(element);
	        this.isHovering = true;
	        this.container.style.cursor = cursorStyle;
	        if ( this.animated ) {
	            scaleDownAnimation.stop();
	            scaleUpAnimation.start();

	        }
			
	        if ( element && event.mouseEvent.clientX >= 0 && event.mouseEvent.clientY >= 0 ) {

	            var { left, right, style } = element;
				
	            if ( this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO ) {
					console.log("-------7-------------");
	                style.display = 'none';
	                left.style.display = 'block';
	                right.style.display = 'block';

	                // Store element width for reference
	                element._width = left.clientWidth;
	                element._height = left.clientHeight;

	            } else {
					console.log("-------8-------------");
	                style.display = 'block';
	                if ( left ) { left.style.display = 'none'; }
	                if ( right ) { right.style.display = 'none'; }

	                // Store element width for reference
	                element._width = element.clientWidth;
	                element._height = element.clientHeight;

	            }
				
	        }

	    },

	    /**
	     * This will be called on a mouse hover end
	     * Sets cursor style to 'default', hide the element and scale down the infospot
	     * @memberOf Infospot
	     * @instance
	     */
	    onHoverEnd: function () {
			//console.log("-------onHoverEnd-------------");
	        if ( !this.getContainer() ) { return; }

	        const { scaleDownAnimation, scaleUpAnimation, element } = this;
			//console.log(element);
	        this.isHovering = false;
	        this.container.style.cursor = 'default';

	        if ( this.animated ) {

	            scaleUpAnimation.stop();
	            scaleDownAnimation.start();

	        }

	        if ( element && !this.element.locked ) {

	            const { left, right, style } = element;

	            style.display = 'none';
	            if ( left ) { left.style.display = 'none'; }
	            if ( right ) { right.style.display = 'none'; }

	            this.unlockHoverElement();

	        }

	    },

	    /**
	     * On dual eye effect handler
	     * Creates duplicate left and right element
	     * @param  {object} event - panolens-dual-eye-effect event
	     * @memberOf Infospot
	     * @instance
	     */
	    onDualEyeEffect: function ( event ) {
	        if ( !this.getContainer() ) { return; }

	        let element, halfWidth, halfHeight;

	        this.mode = event.mode;

	        element = this.element;

	        halfWidth = this.container.clientWidth / 2;
	        halfHeight = this.container.clientHeight / 2;

	        if ( !element ) {

	            return;

	        }

	        if ( !element.left && !element.right ) {

	            element.left = element.cloneNode( true );
	            element.right = element.cloneNode( true );

	        }

	        if ( this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO ) {
	            element.left.style.display = element.style.display;
	            element.right.style.display = element.style.display;
	            element.style.display = 'none';

	        } else {

	            element.style.display = element.left.style.display;
	            element.left.style.display = 'none';
	            element.right.style.display = 'none';

	        }

	        // Update elements translation
	        this.translateElement( halfWidth, halfHeight );

	        this.container.appendChild( element.left );
	        this.container.appendChild( element.right );

	    },

	    /**
	     * Translate the hovering element by css transform
	     * @param  {number} x - X position on the window screen
	     * @param  {number} y - Y position on the window screen
	     * @memberOf Infospot
	     * @instance
	     */
	    translateElement: function ( x, y ) {

	        if ( !this.element._width || !this.element._height || !this.getContainer() ) {

	            return;

	        }

	        let left, top, element, width, height, delta, container;

	        container = this.container;
	        element = this.element;
	        width = element._width / 2;
	        height = element._height / 2;
	        delta = element.verticalDelta !== undefined ? element.verticalDelta : 40;

	        left = x - width;
	        top = y - height - delta;

	        if ( ( this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO ) 
					&& element.left && element.right
					&& !( x === container.clientWidth / 2 && y === container.clientHeight / 2 ) ) {

	            left = container.clientWidth / 4 - width + ( x - container.clientWidth / 2 );
	            top = container.clientHeight / 2 - height - delta + ( y - container.clientHeight / 2 );

	            this.setElementStyle( 'transform', element.left, 'translate(' + left + 'px, ' + top + 'px)' );

	            left += container.clientWidth / 2;

	            this.setElementStyle( 'transform', element.right, 'translate(' + left + 'px, ' + top + 'px)' );

	        } else {

	            this.setElementStyle( 'transform', element, 'translate(' + left + 'px, ' + top + 'px)' );

	        }

	    },

	    /**
	     * Set vendor specific css
	     * @param {string} type - CSS style name
	     * @param {HTMLElement} element - The element to be modified
	     * @param {string} value - Style value
	     * @memberOf Infospot
	     * @instance
	     */
	    setElementStyle: function ( type, element, value ) {

	        const style = element.style;

	        if ( type === 'transform' ) {

	            style.webkitTransform = style.msTransform = style.transform = value;

	        }

	    },

	    /**
	     * Set hovering text content
	     * @param {string} text - Text to be displayed
	     * @memberOf Infospot
	     * @instance
	     */
	    setText: function ( text ) {

	        if ( this.element ) {

	            this.element.textContent = text;

	        }

	    },

	    /**
	     * Set cursor css style on hover
	     * @memberOf Infospot
	     * @instance
	     */
	    setCursorHoverStyle: function ( style ) {

	        this.cursorStyle = style;

	    },

	    /**
	     * Add hovering text element
	     * @param {string} text - Text to be displayed
	     * @param {number} [delta=40] - Vertical delta to the infospot
	     * @memberOf Infospot
	     * @instance
	     */
	    addHoverText: function ( text, delta = 40 ) {
	        if ( !this.element ) {
	            this.element = document.createElement( 'div' );
	            this.element.style.display = 'none';
	            this.element.style.color = '#fff';
	            this.element.style.top = '-25px';
	            this.element.style.maxWidth = '50%';
	            this.element.style.maxHeight = '50%';
	            this.element.style.textShadow = '2px 2px 5px #666666';
	            this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif';
	            this.element.style.position = 'absolute';
	            this.element.classList.add( 'panolens-infospot' );
	            this.element.verticalDelta = delta;
	            this.element.style.fontSize = '20px';

	        }

	        this.setText( text );

	    },

	    /**
	     * Add hovering element by cloning an element
	     * @param {HTMLDOMElement} el - Element to be cloned and displayed
	     * @param {number} [delta=40] - Vertical delta to the infospot
	     * @memberOf Infospot
	     * @instance
	     */
	    addHoverElement: function ( el, delta = 40 ) {

	        if ( !this.element ) { 

	            this.element = el.cloneNode( true );
	            this.element.style.display = 'none';
	            this.element.style.top = 0;
	            this.element.style.position = 'absolute';
	            this.element.classList.add( 'panolens-infospot' );
	            this.element.verticalDelta = delta;

	        }

	    },

	    /**
	     * Remove hovering element
	     * @memberOf Infospot
	     * @instance
	     */
	    removeHoverElement: function () {

	        if ( this.element ) { 

	            if ( this.element.left ) {

	                this.container.removeChild( this.element.left );
	                this.element.left = null;

	            }

	            if ( this.element.right ) {

	                this.container.removeChild( this.element.right );
	                this.element.right = null;

	            }

	            this.container.removeChild( this.element );
	            this.element = null;

	        }

	    },

	    /**
	     * Lock hovering element
	     * @memberOf Infospot
	     * @instance
	     */
	    lockHoverElement: function () {

	        if ( this.element ) { 

	            this.element.locked = true;

	        }

	    },

	    /**
	     * Unlock hovering element
	     * @memberOf Infospot
	     * @instance
	     */
	    unlockHoverElement: function () {

	        if ( this.element ) { 

	            this.element.locked = false;

	        }

	    },

	    /**
	     * Enable raycasting
	     * @param {boolean} [enabled=true]
	     * @memberOf Infospot
	     * @instance
	     */
	    enableRaycast: function ( enabled = true ) {

	        if ( enabled ) {

	            this.raycast = this.originalRaycast;

	        } else {

	            this.raycast = () => {};

	        }

	    },

	    /**
	     * Show infospot
	     * @param  {number} [delay=0] - Delay time to show
	     * @memberOf Infospot
	     * @instance
	     */
	    show: function ( delay = 0 ) {

	        const { animated, hideAnimation, showAnimation, material } = this;

	        if ( animated ) {

	            hideAnimation.stop();
	            showAnimation.delay( delay ).start();

	        } else {

	            this.enableRaycast( true );
	            material.opacity = 1;

	        }

	    },

	    /**
	     * Hide infospot
	     * @param  {number} [delay=0] - Delay time to hide
	     * @memberOf Infospot
	     * @instance
	     */
	    hide: function ( delay = 0 ) {

	        const { animated, hideAnimation, showAnimation, material } = this;

	        if ( animated ) {

	            showAnimation.stop();
	            hideAnimation.delay( delay ).start();

	        } else {

	            this.enableRaycast( false );
	            material.opacity = 0;

	        }
			
	    },

	    /**
	     * Set focus event handler
	     * @memberOf Infospot
	     * @instance
	     */
	    setFocusMethod: function ( event ) {

	        if ( event ) {

	            this.HANDLER_FOCUS = event.method;

	        }

	    },

	    /**
	     * Focus camera center to this infospot
	     * @param {number} [duration=1000] - Duration to tween
	     * @param {function} [easing=TWEEN.Easing.Exponential.Out] - Easing function
	     * @memberOf Infospot
	     * @instance
	     */
	    focus: function ( duration, easing ) {

	        if ( this.HANDLER_FOCUS ) {

	            this.HANDLER_FOCUS( this.position, duration, easing );
	            this.onDismiss();

	        }

	    },

	    /**
	     * Dispose
	     * @memberOf Infospot
	     * @instance
	     */
	    dispose: function () {

	        const { geometry, material } = this;
	        const { map } = material;

	        this.removeHoverElement();

	        if ( this.parent ) {

	            this.parent.remove( this );

	        }

	        if ( map ) { map.dispose(); material.map = null; }
	        if ( geometry ) { geometry.dispose(); this.geometry = null; }
	        if ( material ) { material.dispose(); this.material = null; }

	    }

	} );

	/**
	 * @classdesc Widget for controls
	 * @constructor
	 * @param {HTMLElement} container - A domElement where default control widget will be attached to
	 */
	function Widget ( Viewer ) {
		this.viewer = Viewer;

	    if ( !Viewer ) {

	        console.warn( 'PANOLENS.Widget: No container specified' );

	    }

	    THREE.EventDispatcher.call( this );

	    this.DEFAULT_TRANSITION  = 'all 0.27s ease';
	    this.TOUCH_ENABLED = !!(( 'ontouchstart' in window ) || window.DocumentTouch && document instanceof DocumentTouch);
	    this.PREVENT_EVENT_HANDLER = function ( event ) {
	        event.preventDefault();
	        event.stopPropagation();
	    };

	    this.container = Viewer.container;

	    this.barElement = null;
	    this.fullscreenElement = null;
		this.prevElement = null;
		this.nextElement = null;
	    this.videoElement = null;
	    this.settingElement = null;
		this.closeElement = null;

	    this.mainMenu = null;

	    this.activeMainItem = null;
	    this.activeSubMenu = null;
	    this.mask = null;

	}

	Widget.prototype = Object.assign( Object.create( THREE.EventDispatcher.prototype ), {

	    constructor: Widget,

	    /**
	     * Add control bar
	     * @memberOf Widget
	     * @instance
	     */
	    addControlBar: function () {

	        if ( !this.container ) {

	            console.warn( 'Widget container not set' ); 
	            return; 
	        }

	        var scope = this, bar, styleTranslate, styleOpacity, gradientStyle;

	        gradientStyle = 'linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))';

	        bar = document.createElement( 'div' );
	        bar.style.width = '100%';
	        bar.style.height = '100%';
	        bar.style.float = 'left';
	        bar.style.transform = bar.style.webkitTransform = bar.style.msTransform = 'translateY(-100%)';
	        bar.style.background = '-webkit-' + gradientStyle;
	        bar.style.background = '-moz-' + gradientStyle;
	        bar.style.background = '-o-' + gradientStyle;
	        bar.style.background = '-ms-' + gradientStyle;
	        bar.style.background = gradientStyle;
	        bar.style.transition = this.DEFAULT_TRANSITION;
	        bar.style.pointerEvents = 'none';
	        bar.isHidden = false;
	        bar.toggle = function () {
	            bar.isHidden = !bar.isHidden;
	            styleTranslate = bar.isHidden ? 'translateY(0)' : 'translateY(-100%)';
	            styleOpacity = bar.isHidden ? 0 : 1;
	            bar.style.transform = bar.style.webkitTransform = bar.style.msTransform = styleTranslate;
	            bar.style.opacity = styleOpacity;
	        };

	        // Menu
	        var menu = this.createDefaultMenu();
	        this.mainMenu = this.createMainMenu( menu );
	        bar.appendChild( this.mainMenu );

	        // Mask
	        var mask = this.createMask();
	        this.mask = mask;
	        this.container.appendChild( mask );

	        // Dispose
	        bar.dispose = function () {

	            if ( scope.fullscreenElement ) {

	                bar.removeChild( scope.fullscreenElement );
	                scope.fullscreenElement.dispose();
	                scope.fullscreenElement = null;

	            }

	            if ( scope.settingElement ) {

	                bar.removeChild( scope.settingElement );
	                scope.settingElement.dispose();
	                scope.settingElement = null;

	            }

	            if ( scope.videoElement ) {

	                bar.removeChild( scope.videoElement );
	                scope.videoElement.dispose();
	                scope.videoElement = null;

	            }

	        };

	        this.container.appendChild( bar );

	        // Mask events
	        this.mask.addEventListener( 'mousemove', this.PREVENT_EVENT_HANDLER, true );
	        this.mask.addEventListener( 'mouseup', this.PREVENT_EVENT_HANDLER, true );
	        this.mask.addEventListener( 'mousedown', this.PREVENT_EVENT_HANDLER, true );
	        this.mask.addEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'click', function ( event ) {

	            event.preventDefault();
	            event.stopPropagation();

	            //scope.mask.hide();
	            //scope.settingElement.deactivate();

	        }, false );

	        // Event listener
	        this.addEventListener( 'control-bar-toggle', bar.toggle );

	        this.barElement = bar;

	    },

	    /**
	     * Create default menu
	     * @memberOf Widget
	     * @instance
	     */
	    createDefaultMenu: function () {

	        var scope = this, handler;

	        handler = function ( method, data ) {

	            return function () {

	                scope.dispatchEvent( { 

	                    type: 'panolens-viewer-handler', 
	                    method: method, 
	                    data: data 

	                } ); 

	            };

	        };

	        return [

	            { 
	                title: 'Control', 
	                subMenu: [ 
	                    { 
	                        title: this.TOUCH_ENABLED ? 'Touch' : 'Mouse', 
	                        handler: handler( 'enableControl', CONTROLS.ORBIT )
	                    },
	                    { 
	                        title: 'Sensor', 
	                        handler: handler( 'enableControl', CONTROLS.DEVICEORIENTATION ) 
	                    } 
	                ]
	            },

	            { 
	                title: 'Mode', 
	                subMenu: [ 
	                    { 
	                        title: 'Normal',
	                        handler: handler( 'disableEffect' )
	                    }, 
	                    { 
	                        title: 'Cardboard',
	                        handler: handler( 'enableEffect', MODES.CARDBOARD )
	                    },
	                    { 
	                        title: 'Stereoscopic',
	                        handler: handler( 'enableEffect', MODES.STEREO )
	                    }
	                ]
	            }

	        ];

	    },

	    /**
	     * Add buttons on top of control bar
	     * @param {string} name - The control button name to be created
	     * @memberOf Widget
	     * @instance
	     */
	    addControlButton: function ( name ) {

	        let element;

	        switch( name ) {

	        case 'fullscreen':

	            element = this.createFullscreenButton();
	            this.fullscreenElement = element; 

	            break;
				
			case 'next':

	            element = this.createNextButton();
	            this.nextElement = element; 

	            break;
				
			case 'prev':

	            element = this.createPrevButton();
	            this.prevElement = element; 

	            break;
			
			case 'close':

	            element = this.createCloseButton();
	            this.closeElement = element; 

	            break;

	        case 'setting':

	            element = this.createSettingButton();
	            this.settingElement = element;

	            break;

	        case 'video':

	            element = this.createVideoControl();
	            this.videoElement = element;

	            break;

	        default:

	            return;

	        }

	        if ( !element ) {

	            return;

	        }

	        this.barElement.appendChild( element );

	    },

	    /**
	     * Create modal mask
	     * @memberOf Widget
	     * @instance
	     */
	    createMask: function () {

	        const element = document.createElement( 'div' );
	        element.style.position = 'absolute';
	        element.style.top = 0;
	        element.style.left = 0;
	        element.style.width = '100%';
	        element.style.height = '100%';
	        element.style.background = 'transparent';
	        element.style.display = 'none';

	        element.show = function () {

	            this.style.display = 'block';

	        };

	        element.hide = function () {

	            this.style.display = 'none';

	        };

	        return element;

	    },
		
		createNextButton:function(){
			let scope = this, item;

	        function onTap ( event ) {
				
	            event.preventDefault();
	            event.stopPropagation();
	            //scope.mainMenu.toggle();
				try{
					scope.prevElement.style.backgroundImage =  'url("' + DataImage.Prev + '")'; 
					
					/* if(currentPanoName != "")
					{
						currentPanoObj = shipDeck.infoLinkdict[currentPanoName];
						shipDeck.viewer.remove( currentPanoObj );
					} */
					console.log("isLoadingPanorama : "+isLoadingPanorama);
					if(!isLoadingPanorama)
					{
						isLoadingPanorama = true;
						findPanoImageFromCounter();
						panoCounter++;
						if(panoCounter > (shipDeck.PanoList.length - 1))
						{	
							panoCounter = shipDeck.PanoList.length - 1;
							scope.nextElement.style.backgroundImage =  'url("' + DataImage.Next_disable + '")'; 
							isLoadingPanorama = false;
							// do nothing and disable icon
						}
						else if(panoCounter == (shipDeck.PanoList.length - 1))
						{
							scope.nextElement.style.backgroundImage =  'url("' + DataImage.Next_disable + '")'; 
							SetPanoToView();
						}
						else
						{
							scope.nextElement.style.backgroundImage =  'url("' + DataImage.Next + '")'; 
							SetPanoToView();
						}
						
					}
					else
					{
						console.log("Loading please wait...");
					}
					
				}
				catch(e)
				{
					console.info("-----------errrr found-------createNextButton-------");
					console.info(e);
				}
	            //NextClickFunction();
				
	        }
			
	        item = this.createCustomItem( { 

	            style: { 

	                backgroundImage: 'url("' + DataImage.Next + '")',
					right: "25px",
					bottom: '25px',
					backgroundPosition: 'right bottom',
					position: 'absolute'

	            },

	            onTap: onTap

	        } );
			
			return item;
			
		},
		
		createPrevButton:function(){
			let scope = this, item;

	        function onTap ( event ) {
				
	            event.preventDefault();
	            event.stopPropagation();
	            //scope.mainMenu.toggle();
				scope.nextElement.style.backgroundImage =  'url("' + DataImage.Next + '")'; 
				/* if(currentPanoName != "")
				{
					currentPanoObj = shipDeck.infoLinkdict[currentPanoName];
					shipDeck.viewer.remove( currentPanoObj );
				} */
				if(!isLoadingPanorama)
				{
					isLoadingPanorama = true;
					findPanoImageFromCounter();
					panoCounter--;
					if(panoCounter < 0)
					{
						panoCounter = 0;
						//console.log(shipDeck.viewer.widget.prevElement);
						//console.log(shipDeck.viewer.DataImage);
						scope.prevElement.style.backgroundImage =  'url("' + DataImage.Prev_disable + '")'; 
						isLoadingPanorama = false;
						// do nothing and disable icon
					}
					else if(panoCounter == 0)
					{
						scope.prevElement.style.backgroundImage =  'url("' + DataImage.Prev_disable + '")'; 
						SetPanoToView();
						
					}
					else
					{
						SetPanoToView();
						scope.prevElement.style.backgroundImage =  'url("' + DataImage.Prev + '")'; 
					}
				}
	            //PrevClickFunction();
	        }

	        item = this.createCustomItem( { 

	            style: { 

	                backgroundImage: 'url("' + DataImage.Prev + '")',
					left: "25px",
					bottom: '25px',
					backgroundPosition: 'left bottom',
					position: 'absolute'

	            },

	            onTap: onTap

	        } );
			
			return item;
			
		},
		
		
		createCloseButton: function(){
			let scope = this, item;

	        function onTap ( event ) {
				
	            event.preventDefault();
	            event.stopPropagation();
	            //scope.mainMenu.toggle();
				scope.settingElement.deactivate();
	            HomeButtonClick();
	        }
			
			var topPx = "40px";
			
			if(mobileOperatingSystem != "iOS")
			{
				topPx = "20px";
			}
			
			item = this.createCustomItem( { 

	            style: { 

	                backgroundImage: 'url("' + DataImage.Close + '")',
					width: '44px',
					backgroundPosition: 'right top',
					top: topPx,
					right: '25px',
					position: 'absolute'

	            },

	            onTap: onTap

	        } );
			
			
			/* item = document.createElement( 'span' );
			item.style.backgroundImage=  'url("' + DataImage.Close + '")';
			item.style.cursor = 'pointer';
			item.style.position = 'absolute';
			item.style.top = '10px';
			item.style.right = '10px';
			item.style.width = '24px';
			
			$(".panolens-container").append(item);
			
			item.addEventListener("mousedown", onTap, {passive : false});
		    item.addEventListener("touchstart", onTap , {passive : false}); */
			
			
			return item;
		},

	    /**
	     * Create Setting button to toggle menu
	     * @memberOf Widget
	     * @instance
	     */
	    createSettingButton: function () {

	        let scope = this, item;

	        function onTap ( event ) {
				
	            event.preventDefault();
	            event.stopPropagation();
	            //scope.mainMenu.toggle();
				
	            if ( this.activated ) {
	                this.deactivate();

	            } else {
	                this.activate();

	            }
	        }
			
			var rightPx = "65px";
			
			if(mobileOperatingSystem != "iOS")
			{
				rightPx = "105px";
			}
			
			var isDisplay = "block";
			if(mobileOperatingSystem == "unknown")
			{
				isDisplay = "none";
			}

	        item = this.createCustomItem( { 

	            style: { 

	                backgroundImage: 'url("' + DataImage.Vr_Disable + '")',
	                webkitTransition: this.DEFAULT_TRANSITION,
	                transition: this.DEFAULT_TRANSITION,
					right: rightPx,
					bottom: '25px',
					backgroundPosition: 'right bottom',
					position: 'absolute',
					display: isDisplay

	            },

	            onTap: onTap

	        } );

	        item.activate = function () {
				scope.nextElement.style.display =  'none';
				scope.prevElement.style.display =  'none';
	            //this.style.transform = 'rotate3d(0,0,1,90deg)';
				this.style.backgroundImage = 'url("' + DataImage.Vr_Enable + '")' ;
	            this.activated = true;
	            scope.mask.show();
				scope.viewer.enableEffect(2);

	        };

	        item.deactivate = function () {
				scope.viewer.disableEffect();
	            //this.style.transform = 'rotate3d(0,0,0,0)';
				this.style.backgroundImage = 'url("' + DataImage.Vr_Disable + '")';
	            this.activated = false;
	            scope.mask.hide();

	            if ( scope.mainMenu && scope.mainMenu.visible ) {

	                scope.mainMenu.hide();
					
	            }

	            if ( scope.activeSubMenu && scope.activeSubMenu.visible ) {

	                scope.activeSubMenu.hide();

	            }

	            if ( scope.mainMenu && scope.mainMenu._width ) {

	                scope.mainMenu.changeSize( scope.mainMenu._width );
	                scope.mainMenu.unslideAll();

	            }
				
				scope.nextElement.style.display =  'block'; 
				scope.prevElement.style.display =  'block'; 
				
	        };

	        item.activated = false;
			
			//this.activated = true;
			//scope.viewer.enableEffect(2);

	        return item;

	    },

	    /**
	     * Create Fullscreen button
	     * @return {HTMLSpanElement} - The dom element icon for fullscreen
	     * @memberOf Widget
	     * @instance
	     * @fires Widget#panolens-viewer-handler
	     */
		
		EnableDisableFullScreen: function(){
			const { container } = this;
			tapSkipped = false;
			if ( !isFullscreen ) {

				if ( container.requestFullscreen ) { container.requestFullscreen(); }
				if ( container.msRequestFullscreen ) { container.msRequestFullscreen(); }
				if ( container.mozRequestFullScreen ) { container.mozRequestFullScreen(); }
				if ( container.webkitRequestFullscreen ) { container.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT ); }
		  
				isFullscreen = true;

			} else {

				if ( document.exitFullscreen ) {
					document.exitFullscreen().catch(err => {
					  //console.log("Error attempting to enable full-screen mode");
					});
				}
				if ( document.msExitFullscreen ) { document.msExitFullscreen(); }
				if ( document.mozCancelFullScreen ) { document.mozCancelFullScreen(); }
				if ( document.webkitExitFullscreen ) { document.webkitExitFullscreen( ); }
				isFullscreen = false;

			}
			
			this.fullscreenElement.style.backgroundImage = ( isFullscreen ) 
	                ? 'url("' + DataImage.FullscreenLeave + '")' 
	                : 'url("' + DataImage.FullscreenEnter + '")'; 
		},
		 
	    createFullscreenButton: function () {
	        let scope = this, item, /* isFullscreen = false, */ /* tapSkipped = true, */ stylesheetId;

	        const { container } = this;

	        stylesheetId = 'panolens-style-addon';

	        // Don't create button if no support
	        if ( !document.fullscreenEnabled       && 
				!document.webkitFullscreenEnabled &&
				!document.mozFullScreenEnabled    &&
				!document.msFullscreenEnabled ) {
	            return;
	        }

	        function onTap ( event ) {
	            event.preventDefault();
	            event.stopPropagation();
	            //tapSkipped = false;
				
				if(mobileOperatingSystem != "iOS")
				{
					//isFullscreen = false;
					scope.EnableDisableFullScreen();
				}
				
	            /* this.style.backgroundImage = ( isFullscreen ) 
	                ? 'url("' + DataImage.FullscreenLeave + '")' 
	                : 'url("' + DataImage.FullscreenEnter + '")'; */
					
	        }

	        function onFullScreenChange (eev) {
	            /**
	             * Viewer handler event
	             * @type {object}
	             * @event Widget#panolens-viewer-handler
	             * @property {string} method - 'onWindowResize' function call on Viewer
	             */
				if(tapSkipped)
				{
					isFullscreen = !isFullscreen;
					scope.fullscreenElement.style.backgroundImage = ( isFullscreen ) 
	                ? 'url("' + DataImage.FullscreenLeave + '")' 
	                : 'url("' + DataImage.FullscreenEnter + '")'; 
				}
	            scope.dispatchEvent( { type: 'panolens-viewer-handler', method: 'onWindowResize' } );
	            tapSkipped = true;
	        }

	        document.addEventListener( 'fullscreenchange', onFullScreenChange, false );
	        document.addEventListener( 'webkitfullscreenchange', onFullScreenChange, false );
	        document.addEventListener( 'mozfullscreenchange', onFullScreenChange, false );
	        document.addEventListener( 'MSFullscreenChange', onFullScreenChange, false );

	        item = this.createCustomItem( { 

	            style: { 

	                backgroundImage: 'url("' + DataImage.FullscreenEnter + '")',
					right: '62px',
					bottom: '25px',
					backgroundPosition: 'right bottom',
					position: 'absolute'

	            },

	            onTap: onTap

	        } );

	        // Add fullscreen stlye if not exists
	        if ( !document.querySelector( stylesheetId ) ) {
	            const sheet = document.createElement( 'style' );
	            sheet.id = stylesheetId;
	            sheet.innerHTML = ':-webkit-full-screen { width: 100% !important; height: 100% !important }';
	            document.body.appendChild( sheet );
	        }
	        return item;

	    },

	    /**
	     * Create video control container
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLSpanElement} - The dom element icon for video control
	     */
	    createVideoControl: function () {

	        const item = document.createElement( 'span' );
	        item.style.display = 'none';
	        item.show = function () { 

	            item.style.display = '';

	        };

	        item.hide = function () { 

	            item.style.display = 'none';
	            item.controlButton.paused = true;
	            item.controlButton.update();

	        };

	        item.controlButton = this.createVideoControlButton();
	        item.seekBar = this.createVideoControlSeekbar();
			
	        item.appendChild( item.controlButton );
	        item.appendChild( item.seekBar );

	        item.dispose = function () {

	            item.removeChild( item.controlButton );
	            item.removeChild( item.seekBar );

	            item.controlButton.dispose();
	            item.controlButton = null;

	            item.seekBar.dispose();
	            item.seekBar = null;

	        };

	        this.addEventListener( 'video-control-show', item.show );
	        this.addEventListener( 'video-control-hide', item.hide );

	        return item;

	    },

	    /**
	     * Create video control button
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLSpanElement} - The dom element icon for video control
	     * @fires Widget#panolens-viewer-handler
	     */
	    createVideoControlButton: function () {

	        const scope = this;

	        function onTap ( event ) {

	            event.preventDefault();
	            event.stopPropagation();

	            /**
	             * Viewer handler event
	             * @type {object}
	             * @event Widget#panolens-viewer-handler
	             * @property {string} method - 'toggleVideoPlay' function call on Viewer
	             */
	            scope.dispatchEvent( { type: 'panolens-viewer-handler', method: 'toggleVideoPlay', data: !this.paused } );

	            this.paused = !this.paused;

	            item.update();

	        }
	        const item = this.createCustomItem( { 

	            style: { 

	                float: 'left',
	                backgroundImage: 'url("' + DataImage.VideoPlay + '")'

	            },

	            onTap: onTap

	        } );

	        item.paused = true;

	        item.update = function ( paused ) {

	            this.paused = paused !== undefined ? paused : this.paused;

	            this.style.backgroundImage = 'url("' + ( this.paused 
	                ? DataImage.VideoPlay 
	                : DataImage.VideoPause ) + '")';

	        };

	        return item;

	    },

	    /**
	     * Create video seekbar
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLSpanElement} - The dom element icon for video seekbar
	     * @fires Widget#panolens-viewer-handler
	     */
	    createVideoControlSeekbar: function () {

	        let scope = this, item, progressElement, progressElementControl,
	            isDragging = false, mouseX, percentageNow, percentageNext;

	        progressElement = document.createElement( 'div' );
	        progressElement.style.width = '0%';
	        progressElement.style.height = '100%';
	        progressElement.style.backgroundColor = '#fff';

	        progressElementControl = document.createElement( 'div' );
	        progressElementControl.style.float = 'right';
	        progressElementControl.style.width = '14px';
	        progressElementControl.style.height = '14px';
	        progressElementControl.style.transform = 'translate(7px, -5px)';
	        progressElementControl.style.borderRadius = '50%';
	        progressElementControl.style.backgroundColor = '#ddd';

	        progressElementControl.addEventListener( 'mousedown', onMouseDown, { passive: true } );
	        progressElementControl.addEventListener( 'touchstart', onMouseDown,  { passive: true } );

	        function onMouseDown ( event ) {
	            event.stopPropagation();
				
	            isDragging = true;
				
	            mouseX = event.clientX || ( event.changedTouches && event.changedTouches[0].clientX );

	            percentageNow = parseInt( progressElement.style.width ) / 100;

	            addControlListeners();
	        }

	        function onVideoControlDrag ( event ) {

	            if( isDragging ){

	                const clientX = event.clientX || ( event.changedTouches && event.changedTouches[0].clientX );
					
	                percentageNext = ( clientX - mouseX ) / item.clientWidth;

	                percentageNext = percentageNow + percentageNext;

	                percentageNext = percentageNext > 1 ? 1 : ( ( percentageNext < 0 ) ? 0 : percentageNext );

	                item.setProgress ( percentageNext );

	                /**
	                 * Viewer handler event
	                 * @type {object}
	                 * @event Widget#panolens-viewer-handler
	                 * @property {string} method - 'setVideoCurrentTime' function call on Viewer
	                 * @property {number} data - Percentage of current video. Range from 0.0 to 1.0
	                 */
	                scope.dispatchEvent( { type: 'panolens-viewer-handler', method: 'setVideoCurrentTime', data: percentageNext } );

	            }

	        }

	        function onVideoControlStop ( event ) {

	            event.stopPropagation();

	            isDragging = false;

	            removeControlListeners();

	        }

	        function addControlListeners () {

	            scope.container.addEventListener( 'mousemove', onVideoControlDrag, { passive: true } );
	            scope.container.addEventListener( 'mouseup', onVideoControlStop, { passive: true } );
	            scope.container.addEventListener( 'touchmove', onVideoControlDrag, { passive: true } );
	            scope.container.addEventListener( 'touchend', onVideoControlStop, { passive: true } );


	        }

	        function removeControlListeners () {

	            scope.container.removeEventListener( 'mousemove', onVideoControlDrag, false );
	            scope.container.removeEventListener( 'mouseup', onVideoControlStop, false );
	            scope.container.removeEventListener( 'touchmove', onVideoControlDrag, false );
	            scope.container.removeEventListener( 'touchend', onVideoControlStop, false );

	        }

	        function onTap ( event ) {

	            event.preventDefault();
	            event.stopPropagation();

	            if ( event.target === progressElementControl ) { return; }

	            const percentage = ( event.changedTouches && event.changedTouches.length > 0 )
	                ? ( event.changedTouches[0].pageX - event.target.getBoundingClientRect().left ) / this.clientWidth
	                : event.offsetX / this.clientWidth;

	            /**
	             * Viewer handler event
	             * @type {object}
	             * @property {string} method - 'setVideoCurrentTime' function call on Viewer
	             * @property {number} data - Percentage of current video. Range from 0.0 to 1.0
	             */
	            scope.dispatchEvent( { type: 'panolens-viewer-handler', method: 'setVideoCurrentTime', data: percentage } );

	            item.setProgress( event.offsetX / this.clientWidth );

	        }
	        function onDispose () {

	            removeControlListeners();
	            progressElement = null;
	            progressElementControl = null;

	        }

	        progressElement.appendChild( progressElementControl );

	        item = this.createCustomItem( {

	            style: { 

	                float: 'left',
	                width: '30%',
	                height: '4px',
	                marginTop: '20px',
	                backgroundColor: 'rgba(188,188,188,0.8)'

	            },

	            onTap: onTap,
	            onDispose: onDispose

	        } );

	        item.appendChild( progressElement );

	        item.setProgress = function( percentage ) {

	            progressElement.style.width = percentage * 100 + '%';

	        };		

	        this.addEventListener( 'video-update', function ( event ) { 

	            item.setProgress( event.percentage ); 

	        } );

	        item.progressElement = progressElement;
	        item.progressElementControl = progressElementControl;

	        return item;

	    },

	    /**
	     * Create menu item
	     * @param  {string} title - Title to display
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLElement} - An anchor tag element
	     */
	    createMenuItem: function ( title ) {

	        const scope = this; 
	        const item = document.createElement( 'a' );
	        item.textContent = title;
	        item.style.display = 'block';
	        item.style.padding = '10px';
	        item.style.textDecoration = 'none';
	        item.style.cursor = 'pointer';
	        item.style.pointerEvents = 'auto';
	        item.style.transition = this.DEFAULT_TRANSITION;

	        item.slide = function ( right ) {

	            this.style.transform = 'translateX(' + ( right ? '' : '-' ) + '100%)';

	        };

	        item.unslide = function () {

	            this.style.transform = 'translateX(0)';

	        };

	        item.setIcon = function ( url ) {

	            if ( this.icon ) {

	                this.icon.style.backgroundImage = 'url(' + url + ')';

	            }

	        };

	        item.setSelectionTitle = function ( title ) {

	            if ( this.selection ) {

	                this.selection.textContent = title;

	            }

	        };

	        item.addSelection = function ( name ) {
				
	            const selection = document.createElement( 'span' );
	            selection.style.fontSize = '13px';
	            selection.style.fontWeight = '300';
	            selection.style.float = 'right';

	            this.selection = selection;
	            this.setSelectionTitle( name );
	            this.appendChild( selection );
				
	            return this;

	        };

	        item.addIcon = function ( url = DataImage.ChevronRight, left = false, flip = false ) {
				
	            const element = document.createElement( 'span' );
	            element.style.float = left ? 'left' : 'right';
	            element.style.width = '17px';
	            element.style.height = '17px';
	            element.style[ 'margin' + ( left ? 'Right' : 'Left' ) ] = '12px';
	            element.style.backgroundSize = 'cover';

	            if ( flip ) {

	                element.style.transform = 'rotateZ(180deg)';

	            }

	            this.icon = element;
	            this.setIcon( url );
	            this.appendChild( element );

	            return this;

	        };

	        item.addSubMenu = function ( title, items ) {

	            this.subMenu = scope.createSubMenu( title, items );

	            return this;

	        };

	        item.addEventListener( 'mouseenter', function () {
				
	            this.style.backgroundColor = '#e0e0e0';

	        }, false );

	        item.addEventListener( 'mouseleave', function () {
				
	            this.style.backgroundColor = '#fafafa';

	        }, false );

	        return item;

	    },

	    /**
	     * Create menu item header
	     * @param  {string} title - Title to display
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLElement} - An anchor tag element
	     */
	    createMenuItemHeader: function ( title ) {

	        const header = this.createMenuItem( title );

	        header.style.borderBottom = '1px solid #333';
	        header.style.paddingBottom = '15px';

	        return header;

	    },

	    /**
	     * Create main menu
	     * @param  {array} menus - Menu array list
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLElement} - A span element
	     */
	    createMainMenu: function ( menus ) {
			
	        let scope = this, menu = this.createMenu();

	        menu._width = 200;
	        menu.changeSize( menu._width );

	        function onTap ( event ) {

	            event.preventDefault();
	            event.stopPropagation();

	            let mainMenu = scope.mainMenu, subMenu = this.subMenu;

	            function onNextTick () {

	                mainMenu.changeSize( subMenu.clientWidth );
	                subMenu.show();
	                subMenu.unslideAll();

	            }

	            mainMenu.hide();
	            mainMenu.slideAll();
	            mainMenu.parentElement.appendChild( subMenu );

	            scope.activeMainItem = this;
	            scope.activeSubMenu = subMenu;

	            window.requestAnimationFrame( onNextTick );

	        }
	        for ( var i = 0; i < menus.length; i++ ) {

	            var item = menu.addItem( menus[ i ].title );

	            item.style.paddingLeft = '20px';

	            item.addIcon()
	                .addEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'click', onTap, false );

	            if ( menus[ i ].subMenu && menus[ i ].subMenu.length > 0 ) {

	                var title = menus[ i ].subMenu[ 0 ].title;

	                item.addSelection( title )
	                    .addSubMenu( menus[ i ].title, menus[ i ].subMenu );

	            }

	        }

	        return menu;

	    },

	    /**
	     * Create sub menu
	     * @param {string} title - Sub menu title
	     * @param {array} items - Item array list
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLElement} - A span element
	     */
	    createSubMenu: function ( title, items ) {

	        let scope = this, menu, subMenu = this.createMenu();

	        subMenu.items = items;
	        subMenu.activeItem = null;

	        function onTap ( event ) {

	            event.preventDefault();
	            event.stopPropagation();

	            menu = scope.mainMenu;
	            menu.changeSize( menu._width );
	            menu.unslideAll();
	            menu.show();
	            subMenu.slideAll( true );
	            subMenu.hide();

	            if ( this.type !== 'header' ) {

	                subMenu.setActiveItem( this );
	                scope.activeMainItem.setSelectionTitle( this.textContent );

	                if ( this.handler ) { this.handler(); }

	            }

	        }

	        subMenu.addHeader( title ).addIcon( undefined, true, true ).addEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'click', onTap, false );

	        for ( let i = 0; i < items.length; i++ ) {

	            const item = subMenu.addItem( items[ i ].title );

	            item.style.fontWeight = 300;
	            item.handler = items[ i ].handler;
	            item.addIcon( ' ', true );
	            item.addEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'click', onTap, false );

	            if ( !subMenu.activeItem ) {

	                subMenu.setActiveItem( item );

	            }

	        }

	        subMenu.slideAll( true );

	        return subMenu;
			
	    },

	    /**
	     * Create general menu
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLElement} - A span element
	     */
	    createMenu: function () {

	        const scope = this;
	        const menu = document.createElement( 'span' );
	        const style = menu.style;

	        style.padding = '5px 0';
	        style.position = 'fixed';
	        style.bottom = '100%';
	        style.right = '14px';
	        style.backgroundColor = '#fafafa';
	        style.fontFamily = 'Helvetica Neue';
	        style.fontSize = '14px';
	        style.visibility = 'hidden';
	        style.opacity = 0;
	        style.boxShadow = '0 0 12pt rgba(0,0,0,0.25)';
	        style.borderRadius = '2px';
	        style.overflow = 'hidden';
	        style.willChange = 'width, height, opacity';
	        style.pointerEvents = 'auto';
	        style.transition = this.DEFAULT_TRANSITION;

	        menu.visible = false;

	        menu.changeSize = function ( width, height ) {

	            if ( width ) {

	                this.style.width = width + 'px';

	            }

	            if ( height ) {

	                this.style.height = height + 'px';

	            }

	        };

	        menu.show = function () {
	            this.style.opacity = 1;
	            this.style.visibility = 'visible';
	            this.visible = true;

	        };

	        menu.hide = function () {
	            this.style.opacity = 0;
	            this.style.visibility = 'hidden';
	            this.visible = false;

	        };

	        menu.toggle = function () {

	            if ( this.visible ) {

	                this.hide();

	            } else {

	                this.show();

	            }

	        };

	        menu.slideAll = function ( right ) {

	            for ( let i = 0; i < menu.children.length; i++ ){

	                if ( menu.children[ i ].slide ) {

	                    menu.children[ i ].slide( right );

	                }

	            }

	        };

	        menu.unslideAll = function () {

	            for ( let i = 0; i < menu.children.length; i++ ){

	                if ( menu.children[ i ].unslide ) {

	                    menu.children[ i ].unslide();

	                }

	            }

	        };

	        menu.addHeader = function ( title ) {

	            const header = scope.createMenuItemHeader( title );
	            header.type = 'header';

	            this.appendChild( header );

	            return header;

	        };

	        menu.addItem = function ( title ) {

	            const item = scope.createMenuItem( title );
	            item.type = 'item';

	            this.appendChild( item );

	            return item;

	        };

	        menu.setActiveItem = function ( item ) {

	            if ( this.activeItem ) {

	                this.activeItem.setIcon( ' ' );

	            }

	            item.setIcon( DataImage.Check );

	            this.activeItem = item;

	        };

	        menu.addEventListener( 'mousemove', this.PREVENT_EVENT_HANDLER, true );
	        menu.addEventListener( 'mouseup', this.PREVENT_EVENT_HANDLER, true );
	        menu.addEventListener( 'mousedown', this.PREVENT_EVENT_HANDLER, true );

	        return menu;

	    },

	    /**
	     * Create custom item element
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLSpanElement} - The dom element icon
	     */
	    createCustomItem: function ( options = {} ) {

	        const scope = this;
	        const item = options.element || document.createElement( 'span' );
	        const { onDispose } = options;

	        item.style.cursor = 'pointer';
	        item.style.float = 'right';
	        item.style.width = '50px';
	        item.style.height = '50px';
	        item.style.backgroundSize = '60%';
	        item.style.backgroundRepeat = 'no-repeat';
	        item.style.backgroundPosition = 
	        item.style.webkitUserSelect = 
			item.style.MozUserSelect = 
			item.style.userSelect = 'none';
	        item.style.position = 
	        item.style.pointerEvents = 'auto';
			//item.style.right = '50px';

	        // White glow on icon
	        item.addEventListener( scope.TOUCH_ENABLED ? 'touchstart' : 'mouseenter', function() {
	            item.style.filter = 
				item.style.webkitFilter = 'drop-shadow(0 0 5px rgba(255,255,255,1))';
	        }, { passive: true });
	        item.addEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'mouseleave', function() {
	            item.style.filter = 
				item.style.webkitFilter = '';
	        }, { passive: true });

	        this.mergeStyleOptions( item, options.style );

	        if ( options.onTap ) {

	            item.addEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'click', options.onTap, false );

	        }

	        item.dispose = function () {

	            item.removeEventListener( scope.TOUCH_ENABLED ? 'touchend' : 'click', options.onTap, false );

	            if ( onDispose ) { options.onDispose(); }

	        };
			
	        return item;

	    },

	    /**
	     * Merge item css style
	     * @param  {HTMLElement} element - The element to be merged with style
	     * @param  {object} options - The style options
	     * @memberOf Widget
	     * @instance
	     * @return {HTMLElement} - The same element with merged styles
	     */
	    mergeStyleOptions: function ( element, options = {} ) {

	        for ( let property in options ){

	            if ( options.hasOwnProperty( property ) ) {

	                element.style[ property ] = options[ property ];

	            }

	        }

	        return element;

	    },

	    /**
	     * Dispose widgets by detaching dom elements from container
	     * @memberOf Widget
	     * @instance
	     */
	    dispose: function () {

	        if ( this.barElement ) {
	            this.container.removeChild( this.barElement );
	            this.barElement.dispose();
	            this.barElement = null;

	        }

	    }
		
	} );

	/**
	 * @classdesc Base Panorama
	 * @constructor
	 * @param {THREE.Geometry} geometry - The geometry for this panorama
	 * @param {THREE.Material} material - The material for this panorama
	 */
	function Panorama ( geometry, material ) {

	    THREE.Mesh.call( this, geometry, material );

	    this.type = 'panorama';

	    this.ImageQualityLow = 1;
	    this.ImageQualityFair = 2;
	    this.ImageQualityMedium = 3;
	    this.ImageQualityHigh = 4;
	    this.ImageQualitySuperHigh = 5;

	    this.animationDuration = 2;

	    this.defaultInfospotSize = 350;

	    this.container = undefined;

	    this.loaded = false;

	    this.linkedSpots = [];

	    this.isInfospotVisible = false;
		
	    this.linkingImageURL = undefined;
	    this.linkingImageScale = undefined;

	    this.material.side = THREE.BackSide;
	    this.material.opacity = 0;

	    this.scale.x *= -1;
	    this.renderOrder = -1;

	    this.active = false;

	    this.infospotAnimation = new Tween.Tween( this ).to( {}, this.animationDuration / 2 );

	    this.addEventListener( 'load', this.fadeIn.bind( this ) );
	    this.addEventListener( 'panolens-container', this.setContainer.bind( this ) );
	    this.addEventListener( 'click', this.onClick.bind( this ) );

	    this.setupTransitions();

	}

	Panorama.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {

	    constructor: Panorama,

	    /**
	     * Adding an object
	     * To counter the scale.x = -1, it will automatically add an 
	     * empty object with inverted scale on x
	     * @memberOf Panorama
	     * @instance
	     * @param {THREE.Object3D} object - The object to be added
	     */
	    add: function ( object ) {

	        let invertedObject;

	        if ( arguments.length > 1 ) {

	            for ( var i = 0; i < arguments.length; i ++ ) {

	                this.add( arguments[ i ] );

	            }

	            return this;

	        }

	        // In case of infospots
	        if ( object instanceof Infospot ) {

	            invertedObject = object;

	            if ( object.dispatchEvent ) {

	                const { container } = this;

	                if ( container ) { object.dispatchEvent( { type: 'panolens-container', container } ); }
					
	                object.dispatchEvent( { type: 'panolens-infospot-focus', method: function ( vector, duration, easing ) {

	                    /**
	                     * Infospot focus handler event
	                     * @type {object}
	                     * @event Panorama#panolens-viewer-handler
	                     * @property {string} method - Viewer function name
	                     * @property {*} data - The argument to be passed into the method
	                     */
	                    this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'tweenControlCenter', data: [ vector, duration, easing ] } );


	                }.bind( this ) } );
	            }

	        } else {

	            // Counter scale.x = -1 effect
	            invertedObject = new THREE.Object3D();
	            invertedObject.scale.x = -1;
	            invertedObject.scalePlaceHolder = true;
	            invertedObject.add( object );

	        }

	        THREE.Object3D.prototype.add.call( this, invertedObject );

	    },

	    load: function () {

	        this.onLoad();
			
	    },

	    /**
	     * Click event handler
	     * @param  {object} event - Click event
	     * @memberOf Panorama
	     * @instance
	     * @fires Infospot#dismiss
	     */
	    onClick: function ( event ) {
			
	        if ( event.intersects && event.intersects.length === 0 ) {

	            this.traverse( function ( object ) {

	                /**
	                 * Dimiss event
	                 * @type {object}
	                 * @event Infospot#dismiss
	                 */
	                object.dispatchEvent( { type: 'dismiss' } );

	            } );

	        }

	    },

	    /**
	     * Set container of this panorama 
	     * @param {HTMLElement|object} data - Data with container information
	     * @memberOf Panorama
	     * @instance
	     * @fires Infospot#panolens-container
	     */
	    setContainer: function ( data ) {

	        let container;

	        if ( data instanceof HTMLElement ) {

	            container = data;

	        } else if ( data && data.container ) {

	            container = data.container;

	        }

	        if ( container ) {

	            this.children.forEach( function ( child ) {

	                if ( child instanceof Infospot && child.dispatchEvent ) {

	                    /**
	                     * Set container event
	                     * @type {object}
	                     * @event Infospot#panolens-container
	                     * @property {HTMLElement} container - The container of this panorama
	                     */
	                    child.dispatchEvent( { type: 'panolens-container', container: container } );

	                }

	            } );

	            this.container = container;

	        }

	    },

	    /**
	     * This will be called when panorama is loaded
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#load
	     */
	    onLoad: function () {

	        this.loaded = true;

	        /**
	         * Load panorama event
	         * @type {object}
	         * @event Panorama#load
	         */
	        this.dispatchEvent( { type: 'load' } );

	    },

	    /**
	     * This will be called when panorama is in progress
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#progress
	     */
	    onProgress: function ( progress ) {

	        /**
	         * Loading panorama progress event
	         * @type {object}
	         * @event Panorama#progress
	         * @property {object} progress - The progress object containing loaded and total amount
	         */
	        this.dispatchEvent( { type: 'progress', progress: progress } );

	    },

	    /**
	     * This will be called when panorama loading has error
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#error
	     */
	    onError: function () {

	        /**
	         * Loading panorama error event
	         * @type {object}
	         * @event Panorama#error
	         */
	        this.dispatchEvent( { type: 'error' } );

	    },

	    /**
	     * Get zoom level based on window width
	     * @memberOf Panorama
	     * @instance
	     * @return {number} zoom level indicating image quality
	     */
	    getZoomLevel: function () {

	        let zoomLevel;

	        if ( window.innerWidth <= 800 ) {

	            zoomLevel = this.ImageQualityFair;

	        } else if ( window.innerWidth > 800 &&  window.innerWidth <= 1280 ) {

	            zoomLevel = this.ImageQualityMedium;

	        } else if ( window.innerWidth > 1280 && window.innerWidth <= 1920 ) {

	            zoomLevel = this.ImageQualityHigh;

	        } else if ( window.innerWidth > 1920 ) {

	            zoomLevel = this.ImageQualitySuperHigh;

	        } else {

	            zoomLevel = this.ImageQualityLow;

	        }

	        return zoomLevel;

	    },

	    /**
	     * Update texture of a panorama
	     * @memberOf Panorama
	     * @instance
	     * @param {THREE.Texture} texture - Texture to be updated
	     */
	    updateTexture: function ( texture ) {

	        this.material.map = texture;
	        this.material.needsUpdate = true;

	    },

	    /**
	     * Toggle visibility of infospots in this panorama
	     * @param  {boolean} isVisible - Visibility of infospots
	     * @param  {number} delay - Delay in milliseconds to change visibility
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#infospot-animation-complete
	     */
	    toggleInfospotVisibility: function ( isVisible, delay ) {

	        delay = ( delay !== undefined ) ? delay : 0;

	        const visible = ( isVisible !== undefined ) ? isVisible : ( this.isInfospotVisible ? false : true );

	        this.traverse( function ( object ) {

	            if ( object instanceof Infospot ) {

	                if ( visible ) {

	                    object.show( delay );

	                } else {

	                    object.hide( delay );

	                }

	            }

	        } );

	        this.isInfospotVisible = visible;

	        // Animation complete event
	        this.infospotAnimation.onComplete( function () {

	            /**
	             * Complete toggling infospot visibility
	             * @event Panorama#infospot-animation-complete
	             * @type {object} 
	             */
	            this.dispatchEvent( { type: 'infospot-animation-complete', visible: visible } );

	        }.bind( this ) ).delay( delay ).start();

	    },

	    /**
	     * Set image of this panorama's linking infospot
	     * @memberOf Panorama
	     * @instance
	     * @param {string} url   - Url to the image asset
	     * @param {number} scale - Scale factor of the infospot
	     */
	    setLinkingImage: function ( url, scale ) {

	        this.linkingImageURL = url;
	        this.linkingImageScale = scale;

	    },

	    /**
	     * Link one-way panorama
	     * @param  {Panorama} pano  - The panorama to be linked to
	     * @param  {THREE.Vector3} position - The position of infospot which navigates to the pano
	     * @param  {number} [imageScale=300] - Image scale of linked infospot
	     * @param  {string} [imageSrc=DataImage.Arrow] - The image source of linked infospot
	     * @memberOf Panorama
	     * @instance
	     */
	    link: function ( pano, position, imageScale, imageSrc , infoText) {

	        let scale, img;

	        this.visible = true;

	        if ( !position ) {

	            console.warn( 'Please specify infospot position for linking' );

	            return;

	        }

	        // Infospot scale
	        if ( imageScale !== undefined ) {

	            scale = imageScale;

	        } else if ( pano.linkingImageScale !== undefined ) {

	            scale = pano.linkingImageScale;

	        } else {

	            scale = 300;

	        }


	        // Infospot image
	        if ( imageSrc ) {

	            img = imageSrc;

	        } else if ( pano.linkingImageURL ) {

	            img = pano.linkingImageURL;

	        } else {

	            img = DataImage.Locate;

	        }

	        // Creates a new infospot
	        const spot = new Infospot( scale, img );
	        spot.position.copy( position );
	        spot.toPanorama = pano;
			spot.addHoverText( infoText );
	        spot.addEventListener( 'click', function () {
				$(".panolens-infospot").css("display","none");
				//document.getElementsByClassName("panolens-infospot").style.display = "none";
				ClickToNextPanoImage(pano);
	            /**
	             * Viewer handler event
	             * @type {object}
	             * @event Panorama#panolens-viewer-handler
	             * @property {string} method - Viewer function name
	             * @property {*} data - The argument to be passed into the method
	             */
	            this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'setPanorama', data: pano } );

	        }.bind( this ) );
			
	        this.linkedSpots.push( spot );

	        this.add( spot );

	        this.visible = false;

	    },
		
		addInfospot: function(scale , img , position , infoText , callbackFun , pano)
		{
			const spot = new Infospot( scale, img );
	        spot.position.copy( position );
	        spot.toPanorama = pano;
			spot.addHoverText( infoText );
	        spot.addEventListener( 'click', callbackFun.bind( this ) );
	        this.linkedSpots.push( spot );
	        this.add( spot );
		},

	    reset: function () {

	        this.children.length = 0;	

	    },

	    setupTransitions: function () {

	        this.fadeInAnimation = new Tween.Tween( this.material )
	            .easing( Tween.Easing.Quartic.Out )
	            .onStart( function () {

	                this.visible = true;
	                // this.material.visible = true;

	                /**
	                 * Enter panorama fade in start event
	                 * @event Panorama#enter-fade-start
	                 * @type {object} 
	                 */
	                this.dispatchEvent( { type: 'enter-fade-start' } );

	            }.bind( this ) );

	        this.fadeOutAnimation = new Tween.Tween( this.material )
	            .easing( Tween.Easing.Quartic.Out )
	            .onComplete( function () {

	                this.visible = false;
	                // this.material.visible = true;

	                /**
	                 * Leave panorama complete event
	                 * @event Panorama#leave-complete
	                 * @type {object} 
	                 */
	                this.dispatchEvent( { type: 'leave-complete' } );

	            }.bind( this ) );

	        this.enterTransition = new Tween.Tween( this )
	            .easing( Tween.Easing.Quartic.Out )
	            .onComplete( function () {

	                /**
	                 * Enter panorama and animation complete event
	                 * @event Panorama#enter-complete
	                 * @type {object} 
	                 */
	                this.dispatchEvent( { type: 'enter-complete' } );

	            }.bind ( this ) )
	            .start();

	        this.leaveTransition = new Tween.Tween( this )
	            .easing( Tween.Easing.Quartic.Out );

	    },

	    onFadeAnimationUpdate: function () {

	        const alpha = this.material.opacity;
	        const { uniforms } = this.material;

	        if ( uniforms && uniforms.opacity ) {
	            uniforms.opacity.value = alpha;
	        }

	    },

	    /**
	     * Start fading in animation
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#enter-fade-complete
	     */
	    fadeIn: function ( duration ) {

	        duration = duration >= 0 ? duration : this.animationDuration;

	        this.fadeOutAnimation.stop();
	        this.fadeInAnimation
	            .to( { opacity: 1 }, duration )
	            .onUpdate( this.onFadeAnimationUpdate.bind( this ) )
	            .onComplete( function () {

	                this.toggleInfospotVisibility( true, duration / 2 );

	                /**
	                 * Enter panorama fade complete event
	                 * @event Panorama#enter-fade-complete
	                 * @type {object} 
	                 */
	                this.dispatchEvent( { type: 'enter-fade-complete' } );			

	            }.bind( this ) )
	            .start();

	    },

	    /**
	     * Start fading out animation
	     * @memberOf Panorama
	     * @instance
	     */
	    fadeOut: function ( duration ) {

	        duration = duration >= 0 ? duration : this.animationDuration;

	        this.fadeInAnimation.stop();
	        this.fadeOutAnimation
	            .to( { opacity: 0 }, duration )
	            .onUpdate( this.onFadeAnimationUpdate.bind( this ) )
	            .start();

	    },

	    /**
	     * This will be called when entering a panorama 
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#enter
	     * @fires Panorama#enter-start
	     */
	    onEnter: function () {
	        const duration = this.animationDuration;

	        this.leaveTransition.stop();
	        this.enterTransition
	            .to( {}, duration )
	            .onStart( function () {
	                /**
	                 * Enter panorama and animation starting event
	                 * @event Panorama#enter-start
	                 * @type {object} 
	                 */
	                this.dispatchEvent( { type: 'enter-start' } );
	                if ( this.loaded ) {

	                    this.fadeIn( duration );

	                } else {

	                    this.load();

	                }
					
	            }.bind( this ) )
	            .start();

	        /**
	         * Enter panorama event
	         * @event Panorama#enter
	         * @type {object} 
	         */
	        this.dispatchEvent( { type: 'enter' } );

	        this.children.forEach( child => {
				
	            child.dispatchEvent( { type: 'panorama-enter' } );

	        } );
	        this.active = true;

	    },

	    /**
	     * This will be called when leaving a panorama
	     * @memberOf Panorama
	     * @instance
	     * @fires Panorama#leave
	     */
	    onLeave: function () {

	        const duration = this.animationDuration;

	        this.enterTransition.stop();
	        this.leaveTransition
	            .to( {}, duration )
	            .onStart( function () {

	                /**
	                 * Leave panorama and animation starting event
	                 * @event Panorama#leave-start
	                 * @type {object} 
	                 */
	                this.dispatchEvent( { type: 'leave-start' } );

	                this.fadeOut( duration );
	                this.toggleInfospotVisibility( false );

	            }.bind( this ) )
	            .start();

	        /**
	         * Leave panorama event
	         * @event Panorama#leave
	         * @type {object} 
	         */
	        this.dispatchEvent( { type: 'leave' } );

	        this.children.forEach( child => {

	            child.dispatchEvent( { type: 'panorama-leave' } );

	        } );

	        this.active = false;

	    },

	    /**
	     * Dispose panorama
	     * @memberOf Panorama
	     * @instance
	     */
	    dispose: function () {

	        this.infospotAnimation.stop();
	        this.fadeInAnimation.stop();
	        this.fadeOutAnimation.stop();
	        this.enterTransition.stop();
	        this.leaveTransition.stop();

	        /**
	         * On panorama dispose handler
	         * @type {object}
	         * @event Panorama#panolens-viewer-handler
	         * @property {string} method - Viewer function name
	         * @property {*} data - The argument to be passed into the method
	         */
	        this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'onPanoramaDispose', data: this } );

	        // recursive disposal on 3d objects
	        function recursiveDispose ( object ) {

	            const { geometry, material } = object;

	            for ( var i = object.children.length - 1; i >= 0; i-- ) {

	                recursiveDispose( object.children[i] );
	                object.remove( object.children[i] );

	            }

	            if ( object instanceof Infospot ) {

	                object.dispose();

	            }
				
	            if ( geometry ) { geometry.dispose(); object.geometry = null; }
	            if ( material ) { material.dispose(); object.material = null; }

	        }

	        recursiveDispose( this );

	        if ( this.parent ) {

	            this.parent.remove( this );

	        }

	    }

	} );

	/**
	 * @classdesc Equirectangular based image panorama
	 * @constructor
	 * @param {string} image - Image url or HTMLImageElement
	 */
	function ImagePanorama ( image, _geometry, _material ) {

	    const radius = 5000;
	    const geometry = _geometry || new THREE.SphereBufferGeometry( radius, 60, 40 );
	    const material = _material || new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } );

	    Panorama.call( this, geometry, material );

	    this.src = image;
	    this.radius = radius;

	}

	ImagePanorama.prototype = Object.assign( Object.create( Panorama.prototype ), {

	    constructor: ImagePanorama,

	    /**
	     * Load image asset
	     * @param  {*} src - Url or image element
	     * @memberOf ImagePanorama
	     * @instance
	     */
	    load: function ( src ) {

	        src = src || this.src;

	        if ( !src ) { 

	            console.warn( 'Image source undefined' );

	            return; 

	        } else if ( typeof src === 'string' ) {

	            TextureLoader.load( src, this.onLoad.bind( this ), this.onProgress.bind( this ), this.onError.bind( this ) );

	        } else if ( src instanceof HTMLImageElement ) {

	            this.onLoad( new THREE.Texture( src ) );

	        }

	    },

	    /**
	     * This will be called when image is loaded
	     * @param  {THREE.Texture} texture - Texture to be updated
	     * @memberOf ImagePanorama
	     * @instance
	     */
	    onLoad: function ( texture ) {

	        texture.minFilter = texture.magFilter = THREE.LinearFilter;
	        texture.needsUpdate = true;
			
	        this.updateTexture( texture );

	        window.requestAnimationFrame( Panorama.prototype.onLoad.bind( this ) );

	    },

	    /**
	     * Reset
	     * @memberOf ImagePanorama
	     * @instance
	     */
	    reset: function () {

	        Panorama.prototype.reset.call( this );

	    },

	    /**
	     * Dispose
	     * @memberOf ImagePanorama
	     * @instance
	     */
	    dispose: function () {

	        const { material: { map } } = this;

	        // Release cached image
	        THREE.Cache.remove( this.src );

	        if ( map ) { map.dispose(); }

	        Panorama.prototype.dispose.call( this );

	    }

	} );

	/**
	 * @classdesc Empty panorama
	 * @constructor
	 */
	function EmptyPanorama () {

	    const geometry = new THREE.BufferGeometry();
	    const material = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0, transparent: true } );

	    geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(), 1 ) );

	    Panorama.call( this, geometry, material );

	}

	EmptyPanorama.prototype = Object.assign( Object.create( Panorama.prototype ), {

	    constructor: EmptyPanorama

	} );

	/**
	 * @classdesc Cubemap-based panorama
	 * @constructor
	 * @param {array} images - Array of 6 urls to images, one for each side of the CubeTexture. The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z
	 */
	function CubePanorama ( images = [] ){

	    const edgeLength = 10000;
	    const shader = Object.assign( {}, THREE.ShaderLib[ 'cube' ] );
	    const geometry = new THREE.BoxBufferGeometry( edgeLength, edgeLength, edgeLength );
	    const material = new THREE.ShaderMaterial( {

	        fragmentShader: shader.fragmentShader,
	        vertexShader: shader.vertexShader,
	        uniforms: shader.uniforms,
	        side: THREE.BackSide,
	        transparent: true

	    } );

	    Panorama.call( this, geometry, material );

	    this.images = images;
	    this.edgeLength = edgeLength;
	    this.material.uniforms.opacity.value = 0;

	}

	CubePanorama.prototype = Object.assign( Object.create( Panorama.prototype ), {

	    constructor: CubePanorama,

	    /**
	     * Load 6 images and bind listeners
	     * @memberOf CubePanorama
	     * @instance
	     */
	    load: function () {

	        CubeTextureLoader.load( 	

	            this.images, 

	            this.onLoad.bind( this ), 
	            this.onProgress.bind( this ), 
	            this.onError.bind( this ) 

	        );

	    },

	    /**
	     * This will be called when 6 textures are ready
	     * @param  {THREE.CubeTexture} texture - Cube texture
	     * @memberOf CubePanorama
	     * @instance
	     */
	    onLoad: function ( texture ) {
			
	        this.material.uniforms[ 'tCube' ].value = texture;

	        Panorama.prototype.onLoad.call( this );

	    },

	    /**
	     * Dispose
	     * @memberOf CubePanorama
	     * @instance
	     */
	    dispose: function () {	

	        const { value } = this.material.uniforms.tCube;

	        this.images.forEach( ( image ) => { THREE.Cache.remove( image ); } );

	        if ( value instanceof THREE.CubeTexture ) {

	            value.dispose();

	        }

	        Panorama.prototype.dispose.call( this );

	    }

	} );

	/**
	 * @classdesc Basic panorama with 6 pre-defined grid images
	 * @constructor
	 */
	function BasicPanorama () {

	    const images = [];

	    for ( let i = 0; i < 6; i++ ) {

	        images.push( DataImage.WhiteTile );

	    }

	    CubePanorama.call( this, images );

	}

	BasicPanorama.prototype = Object.assign( Object.create( CubePanorama.prototype ), {

	    constructor: BasicPanorama

	} );

	/**
	 * @classdesc Video Panorama
	 * @constructor
	 * @param {string} src - Equirectangular video url
	 * @param {object} [options] - Option for video settings
	 * @param {HTMLElement} [options.videoElement] - HTML5 video element contains the video
	 * @param {boolean} [options.loop=true] - Specify if the video should loop in the end
	 * @param {boolean} [options.muted=true] - Mute the video or not. Need to be true in order to autoplay on some browsers
	 * @param {boolean} [options.autoplay=false] - Specify if the video should auto play
	 * @param {boolean} [options.playsinline=true] - Specify if video should play inline for iOS. If you want it to auto play inline, set both autoplay and muted options to true
	 * @param {string} [options.crossOrigin="anonymous"] - Sets the cross-origin attribute for the video, which allows for cross-origin videos in some browsers (Firefox, Chrome). Set to either "anonymous" or "use-credentials".
	 * @param {number} [radius=5000] - The minimum radius for this panoram
	 */
	function VideoPanorama ( src, options = {} ) {

	    const radius = 5000;
	    const geometry = new THREE.SphereBufferGeometry( radius, 60, 40 );
	    const material = new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } );

	    Panorama.call( this, geometry, material );

	    this.src = src;

	    this.options = {

	        videoElement: document.createElement( 'video' ),
	        loop: true,
	        muted: true,
	        autoplay: false,
	        playsinline: true,
	        crossOrigin: 'anonymous'

	    };

	    Object.assign( this.options, options );

	    this.videoElement = this.options.videoElement;
	    this.videoProgress = 0;
	    this.radius = radius;

	    this.addEventListener( 'leave', this.pauseVideo.bind( this ) );
	    this.addEventListener( 'enter-fade-start', this.resumeVideoProgress.bind( this ) );
	    this.addEventListener( 'video-toggle', this.toggleVideo.bind( this ) );
	    this.addEventListener( 'video-time', this.setVideoCurrentTime.bind( this ) );

	}
	VideoPanorama.prototype = Object.assign( Object.create( Panorama.prototype ), {

	    constructor: VideoPanorama,

	    isMobile: function () {

	        let check = false;
	        (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})( window.navigator.userAgent || window.navigator.vendor || window.opera );
	        return check;

	    },

	    /**
	     * Load video panorama
	     * @memberOf VideoPanorama
	     * @instance
	     * @fires  Panorama#panolens-viewer-handler
	     */
	    load: function () {

	        const { muted, loop, autoplay, playsinline, crossOrigin } = this.options;
	        const video = this.videoElement;
	        const material = this.material;
	        const onProgress = this.onProgress.bind( this );
	        const onLoad = this.onLoad.bind( this );

	        video.loop = loop;
	        video.autoplay = autoplay;
	        video.playsinline = playsinline;
	        video.crossOrigin = crossOrigin;
	        video.muted = muted;
			
	        if ( playsinline ) {

	            video.setAttribute( 'playsinline', '' );
	            video.setAttribute( 'webkit-playsinline', '' );

	        } 

	        const onloadeddata = function() {

	            this.setVideoTexture( video );

	            if ( autoplay ) {

	                /**
	                 * Viewer handler event
	                 * @type {object}
	                 * @property {string} method - 'updateVideoPlayButton'
	                 * @property {boolean} data - Pause video or not
	                 */
	                this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'updateVideoPlayButton', data: false } );

	            }

	            // For mobile silent autoplay
	            if ( this.isMobile() ) {

	                video.pause();

	                if ( autoplay && muted ) {

	                    /**
	                     * Viewer handler event
	                     * @type {object}
	                     * @property {string} method - 'updateVideoPlayButton'
	                     * @property {boolean} data - Pause video or not
	                     */
	                    this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'updateVideoPlayButton', data: false } );

	                } else {

	                    /**
	                     * Viewer handler event
	                     * @type {object}
	                     * @property {string} method - 'updateVideoPlayButton'
	                     * @property {boolean} data - Pause video or not
	                     */
	                    this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'updateVideoPlayButton', data: true } );

	                }
					
	            }

	            const loaded = () => {

	                // Fix for threejs r89 delayed update
	                material.map.needsUpdate = true;

	                onProgress( { loaded: 1, total: 1 } );
	                onLoad();

	            };

	            window.requestAnimationFrame( loaded );
				
	        };

	        /**
	         * Ready state of the audio/video element
	         * 0 = HAVE_NOTHING - no information whether or not the audio/video is ready
	         * 1 = HAVE_METADATA - metadata for the audio/video is ready
	         * 2 = HAVE_CURRENT_DATA - data for the current playback position is available, but not enough data to play next frame/millisecond
	         * 3 = HAVE_FUTURE_DATA - data for the current and at least the next frame is available
	         * 4 = HAVE_ENOUGH_DATA - enough data available to start playing
	         */
	        if ( video.readyState > 2 ) {

	            onloadeddata.call( this );

	        } else {

	            if ( video.querySelectorAll( 'source' ).length === 0 ) {

	                const source = document.createElement( 'source' );
	                source.src = this.src;
	                video.appendChild( source );

	            }

	            video.load();
	        }

	        video.addEventListener( 'loadeddata', onloadeddata.bind( this ) );
			
	        video.addEventListener( 'timeupdate', function () {

	            this.videoProgress = video.duration >= 0 ? video.currentTime / video.duration : 0;

	            /**
	             * Viewer handler event
	             * @type {object}
	             * @property {string} method - 'onVideoUpdate'
	             * @property {number} data - The percentage of video progress. Range from 0.0 to 1.0
	             */
	            this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'onVideoUpdate', data: this.videoProgress } );

	        }.bind( this ) );

	        video.addEventListener( 'ended', function () {
				
	            if ( !loop ) {

	                this.resetVideo();
	                this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'updateVideoPlayButton', data: true } );

	            }

	        }.bind( this ), false ); 

	    },

	    /**
	     * Set video texture
	     * @memberOf VideoPanorama
	     * @instance
	     * @param {HTMLVideoElement} video  - The html5 video element
	     * @fires Panorama#panolens-viewer-handler
	     */
	    setVideoTexture: function ( video ) {

	        if ( !video ) return;

	        const videoTexture = new THREE.VideoTexture( video );
	        videoTexture.minFilter = THREE.LinearFilter;
	        videoTexture.magFilter = THREE.LinearFilter;
	        videoTexture.format = THREE.RGBFormat;

	        this.updateTexture( videoTexture );
		
	    },

	    /**
	     * Reset
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    reset: function () {

	        this.videoElement = undefined;	

	        Panorama.prototype.reset.call( this );

	    },

	    /**
	     * Check if video is paused
	     * @memberOf VideoPanorama
	     * @instance
	     * @return {boolean} - is video paused or not
	     */
	    isVideoPaused: function () {

	        return this.videoElement.paused;

	    },

	    /**
	     * Toggle video to play or pause
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    toggleVideo: function () {

	        const video = this.videoElement;

	        if ( !video ) { return; }

	        video[ video.paused ? 'play' : 'pause' ]();

	    },

	    /**
	     * Set video currentTime
	     * @memberOf VideoPanorama
	     * @instance
	     * @param {object} event - Event contains percentage. Range from 0.0 to 1.0
	     */
	    setVideoCurrentTime: function ( { percentage } ) {

	        const video = this.videoElement;

	        if ( video && !Number.isNaN( percentage ) && percentage !== 1 ) {

	            video.currentTime = video.duration * percentage;

	            this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'onVideoUpdate', data: percentage } );

	        }

	    },

	    /**
	     * Play video
	     * @memberOf VideoPanorama
	     * @instance
	     * @fires VideoPanorama#play
	     * @fires VideoPanorama#play-error
	     */
	    playVideo: function () {

	        const video = this.videoElement;
	        const playVideo = this.playVideo.bind( this );
	        const dispatchEvent = this.dispatchEvent.bind( this );
	        const onSuccess = () => {

	            /**
	             * Play event
	             * @type {object}
	             * @event VideoPanorama#play
	             *
	             */
	            dispatchEvent( { type: 'play' } );

	        };
	        const onError = ( error ) => {

	            // Error playing video. Retry next frame. Possibly Waiting for user interaction
	            window.requestAnimationFrame( playVideo );

	            /**
	             * Play event
	             * @type {object}
	             * @event VideoPanorama#play-error
	             *
	             */
	            dispatchEvent( { type: 'play-error', error } );

	        };

	        if ( video && video.paused ) {

	            video.play().then( onSuccess ).catch( onError );

	        }

	    },

	    /**
	     * Pause video
	     * @memberOf VideoPanorama
	     * @instance
	     * @fires VideoPanorama#pause
	     */
	    pauseVideo: function () {

	        const video = this.videoElement;

	        if ( video && !video.paused ) {

	            video.pause();

	        }

	        /**
	         * Pause event
	         * @type {object}
	         * @event VideoPanorama#pause
	         *
	         */
	        this.dispatchEvent( { type: 'pause' } );

	    },

	    /**
	     * Resume video
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    resumeVideoProgress: function () {

	        const video = this.videoElement;

	        if ( video.readyState >= 4 && video.autoplay && !this.isMobile() ) {

	            this.playVideo();

	            /**
	             * Viewer handler event
	             * @type {object}
	             * @property {string} method - 'updateVideoPlayButton'
	             * @property {boolean} data - Pause video or not
	             */
	            this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'updateVideoPlayButton', data: false } );

	        } else {

	            this.pauseVideo();

	            /**
	             * Viewer handler event
	             * @type {object}
	             * @property {string} method - 'updateVideoPlayButton'
	             * @property {boolean} data - Pause video or not
	             */
	            this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'updateVideoPlayButton', data: true } );

	        }

	        this.setVideoCurrentTime( { percentage: this.videoProgress } );

	    },

	    /**
	     * Reset video at stating point
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    resetVideo: function () {

	        const video = this.videoElement;

	        if ( video ) {

	            this.setVideoCurrentTime( { percentage: 0 } );

	        }

	    },

	    /**
	     * Check if video is muted
	     * @memberOf VideoPanorama
	     * @instance
	     * @return {boolean} - is video muted or not
	     */
	    isVideoMuted: function () {

	        return this.videoElement.muted;

	    },

	    /**
	     * Mute video
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    muteVideo: function () {

	        const video = this.videoElement;

	        if ( video && !video.muted ) {

	            video.muted = true;

	        }

	        this.dispatchEvent( { type: 'volumechange' } );

	    },

	    /**
	     * Unmute video
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    unmuteVideo: function () {

	        const video = this.videoElement;

	        if ( video && this.isVideoMuted() ) {

	            video.muted = false;

	        }

	        this.dispatchEvent( { type: 'volumechange' } );

	    },

	    /**
	     * Returns the video element
	     * @memberOf VideoPanorama
	     * @instance
	     * @returns {HTMLElement}
	     */
	    getVideoElement: function () {

	        return this.videoElement;

	    },

	    /**
	     * Dispose video panorama
	     * @memberOf VideoPanorama
	     * @instance
	     */
	    dispose: function () {

	        const { material: { map } } = this;

	        this.pauseVideo();
			
	        this.removeEventListener( 'leave', this.pauseVideo.bind( this ) );
	        this.removeEventListener( 'enter-fade-start', this.resumeVideoProgress.bind( this ) );
	        this.removeEventListener( 'video-toggle', this.toggleVideo.bind( this ) );
	        this.removeEventListener( 'video-time', this.setVideoCurrentTime.bind( this ) );

	        if ( map ) { map.dispose(); }

	        Panorama.prototype.dispose.call( this );

	    }

	} );

	/**
	 * @classdesc Google Street View Loader
	 * @constructor
	 * @param {object} parameters 
	 */
	function GoogleStreetviewLoader ( parameters = {} ) {

	    this._parameters = parameters;
	    this._zoom = null;
	    this._panoId = null;
	    this._panoClient = new google.maps.StreetViewService();
	    this._count = 0;
	    this._total = 0;
	    this._canvas = [];
	    this._ctx = [];
	    this._wc = 0;
	    this._hc = 0;
	    this.result = null;
	    this.rotation = 0;
	    this.copyright = '';
	    this.onSizeChange = null;
	    this.onPanoramaLoad = null;

	    this.levelsW = [ 1, 2, 4, 7, 13, 26 ];
	    this.levelsH = [ 1, 1, 2, 4, 7, 13 ];

	    this.widths = [ 416, 832, 1664, 3328, 6656, 13312 ];
	    this.heights = [ 416, 416, 832, 1664, 3328, 6656 ];

	    this.maxW = 6656;
	    this.maxH = 6656;

	    let gl;

	    try {

	        const canvas = document.createElement( 'canvas' );

	        gl = canvas.getContext( 'experimental-webgl' );

	        if( !gl ) {

	            gl = canvas.getContext( 'webgl' );

	        }

	    }
	    catch ( error ) {

	    }

	    this.maxW = Math.max( gl.getParameter( gl.MAX_TEXTURE_SIZE ), this.maxW );
	    this.maxH = Math.max( gl.getParameter( gl.MAX_TEXTURE_SIZE ), this.maxH );

	}

	Object.assign( GoogleStreetviewLoader.prototype, {

	    constructor: GoogleStreetviewLoader,

	    /**
	     * Set progress
	     * @param {number} loaded 
	     * @param {number} total 
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    setProgress: function ( loaded, total ) {

	        if ( this.onProgress ) {

	            this.onProgress( { loaded: loaded, total: total } );

	        }
			
	    },

	    /**
	     * Adapt texture to zoom
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    adaptTextureToZoom: function () {

	        const w = this.widths [ this._zoom ];
	        const h = this.heights[ this._zoom ];

	        const maxW = this.maxW;
	        const maxH = this.maxH;

	        this._wc = Math.ceil( w / maxW );
	        this._hc = Math.ceil( h / maxH );

	        for( let y = 0; y < this._hc; y++ ) {
	            for( let x = 0; x < this._wc; x++ ) {
	                const c = document.createElement( 'canvas' );
	                if( x < ( this._wc - 1 ) ) c.width = maxW; else c.width = w - ( maxW * x );
	                if( y < ( this._hc - 1 ) ) c.height = maxH; else c.height = h - ( maxH * y );
	                this._canvas.push( c );
	                this._ctx.push( c.getContext( '2d' ) );
	            }
	        }

	    },

	    /**
	     * Compose from tile
	     * @param {number} x 
	     * @param {number} y 
	     * @param {*} texture 
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    composeFromTile: function ( x, y, texture ) {

	        const maxW = this.maxW;
	        const maxH = this.maxH;

	        x *= 512;
	        y *= 512;

	        const px = Math.floor( x / maxW );
	        const py = Math.floor( y / maxH );

	        x -= px * maxW;
	        y -= py * maxH;

	        this._ctx[ py * this._wc + px ].drawImage( texture, 0, 0, texture.width, texture.height, x, y, 512, 512 );

	        this.progress();
			
	    },

	    /**
	     * Progress
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    progress: function() {

	        this._count++;
			
	        this.setProgress( this._count, this._total );
			
	        if ( this._count === this._total) {

	            this.canvas = this._canvas;
	            this.panoId = this._panoId;
	            this.zoom = this._zoom;

	            if ( this.onPanoramaLoad ) {

	                this.onPanoramaLoad( this._canvas[ 0 ] );

	            }

	        }
	    },

	    /**
	     * Compose panorama
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    composePanorama: function () {

	        this.setProgress( 0, 1 );
			
	        const w = this.levelsW[ this._zoom ];
	        const h = this.levelsH[ this._zoom ];
	        const self = this;
				
	        this._count = 0;
	        this._total = w * h;

	        const { useWebGL } = this._parameters;

	        for( let y = 0; y < h; y++ ) {
	            for( let x = 0; x < w; x++ ) {
	                const url = 'https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=' + this._zoom + '&x=' + x + '&y=' + y + '&panoid=' + this._panoId + '&nbt&fover=2';
	                ( function( x, y ) { 
	                    if( useWebGL ) {
	                        const texture = TextureLoader.load( url, null, function() {
	                            self.composeFromTile( x, y, texture );
	                        } );
	                    } else {
	                        const img = new Image();
	                        img.addEventListener( 'load', function() {
	                            self.composeFromTile( x, y, this );			
	                        } );
	                        img.crossOrigin = '';
	                        img.src = url;
	                    }
	                } )( x, y );
	            }
	        }
			
	    },

	    /**
	     * Load
	     * @param {string} panoid 
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    load: function ( panoid ) {

	        this.loadPano( panoid );

	    },

	    /**
	     * Load panorama
	     * @param {string} id
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    loadPano: function( id ) {

	        const self = this;
	        this._panoClient.getPanoramaById( id, function (result, status) {
	            if (status === google.maps.StreetViewStatus.OK) {
	                self.result = result;
	                self.copyright = result.copyright;
	                self._panoId = result.location.pano;
	                self.composePanorama();
	            }
	        });
			
	    },

	    /**
	     * Set zoom level
	     * @param {number} z 
	     * @memberOf GoogleStreetviewLoader
	     * @instance
	     */
	    setZoom: function( z ) {

	        this._zoom = z;
	        this.adaptTextureToZoom();
	    }
		
	} );

	/**
	 * @classdesc Google streetview panorama
	 * @description [How to get Panorama ID]{@link http://stackoverflow.com/questions/29916149/google-maps-streetview-how-to-get-panorama-id}
	 * @constructor
	 * @param {string} panoId - Panorama id from Google Streetview 
	 * @param {string} [apiKey] - Google Street View API Key
	 */
	function GoogleStreetviewPanorama ( panoId, apiKey ) {

	    ImagePanorama.call( this );

	    this.panoId = panoId;

	    this.gsvLoader = null;

	    this.loadRequested = false;

	    this.setupGoogleMapAPI( apiKey );

	}

	GoogleStreetviewPanorama.prototype = Object.assign( Object.create( ImagePanorama.prototype ), {

	    constructor: GoogleStreetviewPanorama,

	    /**
	     * Load Google Street View by panorama id
	     * @param {string} panoId - Gogogle Street View panorama id
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     */
	    load: function ( panoId ) {

	        this.loadRequested = true;

	        panoId = ( panoId || this.panoId ) || {};

	        if ( panoId && this.gsvLoader ) {

	            this.loadGSVLoader( panoId );

	        }

	    },

	    /**
	     * Setup Google Map API
	     * @param {string}  apiKey
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     */
	    setupGoogleMapAPI: function ( apiKey ) {

	        const script = document.createElement( 'script' );
	        script.src = 'https://maps.googleapis.com/maps/api/js?';
	        script.src += apiKey ? 'key=' + apiKey : '';
	        script.onreadystatechange = this.setGSVLoader.bind( this );
	        script.onload = this.setGSVLoader.bind( this );

	        document.querySelector( 'head' ).appendChild( script );

	    },

	    /**
	     * Set GSV Loader
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     */
	    setGSVLoader: function () {

	        this.gsvLoader = new GoogleStreetviewLoader();

	        if ( this.loadRequested ) {

	            this.load();

	        }

	    },

	    /**
	     * Get GSV Loader
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     * @return {GoogleStreetviewLoader} GSV Loader instance
	     */
	    getGSVLoader: function () {

	        return this.gsvLoader;

	    },

	    /**
	     * Load GSV Loader
	     * @param  {string} panoId - Gogogle Street View panorama id
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     */
	    loadGSVLoader: function ( panoId ) {

	        this.loadRequested = false;

	        this.gsvLoader.onProgress = this.onProgress.bind( this );

	        this.gsvLoader.onPanoramaLoad = this.onLoad.bind( this );

	        this.gsvLoader.setZoom( this.getZoomLevel() );

	        this.gsvLoader.load( panoId );

	        this.gsvLoader.loaded = true;
	    },

	    /**
	     * This will be called when panorama is loaded
	     * @param  {HTMLCanvasElement} canvas - Canvas where the tiles have been drawn
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     */
	    onLoad: function ( canvas ) {

	        ImagePanorama.prototype.onLoad.call( this, new THREE.Texture( canvas ) );

	    },

	    /**
	     * Reset
	     * @memberOf GoogleStreetviewPanorama
	     * @instance
	     */
	    reset: function () {

	        this.gsvLoader = undefined;

	        ImagePanorama.prototype.reset.call( this );

	    }

	} );

	/**
	 * Stereographic projection shader
	 * based on http://notlion.github.io/streetview-stereographic
	 * @author pchen66
	 */

	/**
	 * @description Stereograhpic Shader
	 * @module StereographicShader
	 * @property {object} uniforms
	 * @property {THREE.Texture} uniforms.tDiffuse diffuse map
	 * @property {number} uniforms.resolution image resolution
	 * @property {THREE.Matrix4} uniforms.transform transformation matrix
	 * @property {number} uniforms.zoom image zoom factor
	 * @property {number} uniforms.opacity image opacity
	 * @property {string} vertexShader vertex shader
	 * @property {string} fragmentShader fragment shader
	 */
	const StereographicShader = {

	    uniforms: {

	        'tDiffuse': { value: new THREE.Texture() },
	        'resolution': { value: 1.0 },
	        'transform': { value: new THREE.Matrix4() },
	        'zoom': { value: 1.0 },
	        'opacity': { value: 1.0 }

	    },

	    vertexShader: [

	        'varying vec2 vUv;',

	        'void main() {',

	        'vUv = uv;',
	        'gl_Position = vec4( position, 1.0 );',

	        '}' 

	    ].join( '\n' ),

	    fragmentShader: [

	        'uniform sampler2D tDiffuse;',
	        'uniform float resolution;',
	        'uniform mat4 transform;',
	        'uniform float zoom;',
	        'uniform float opacity;',

	        'varying vec2 vUv;',

	        'const float PI = 3.141592653589793;',

	        'void main(){',

	        'vec2 position = -1.0 +  2.0 * vUv;',

	        'position *= vec2( zoom * resolution, zoom * 0.5 );',

	        'float x2y2 = position.x * position.x + position.y * position.y;',
	        'vec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );',

	        'sphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );',

	        'vec2 sampleUV = vec2(',
	        '(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,',
	        '(asin(sphere_pnt.z) / PI + 0.5)',
	        ');',

	        'gl_FragColor = texture2D( tDiffuse, sampleUV );',

	        'gl_FragColor.a *= opacity;',

	        '}'

	    ].join( '\n' )

	};

	/**
	 * @classdesc Little Planet
	 * @constructor
	 * @param {string} type 		- Type of little planet basic class
	 * @param {string} source 		- URL for the image source
	 * @param {number} [size=10000] - Size of plane geometry
	 * @param {number} [ratio=0.5]  - Ratio of plane geometry's height against width
	 */
	function LittlePlanet ( type = 'image', source, size = 10000, ratio = 0.5 ) {

	    if ( type === 'image' ) {

	        ImagePanorama.call( this, source, this.createGeometry( size, ratio ), this.createMaterial( size ) );

	    }

	    this.size = size;
	    this.ratio = ratio;
	    this.EPS = 0.000001;
	    this.frameId = null;

	    this.dragging = false;
	    this.userMouse = new THREE.Vector2();

	    this.quatA = new THREE.Quaternion();
	    this.quatB = new THREE.Quaternion();
	    this.quatCur = new THREE.Quaternion();
	    this.quatSlerp = new THREE.Quaternion();

	    this.vectorX = new THREE.Vector3( 1, 0, 0 );
	    this.vectorY = new THREE.Vector3( 0, 1, 0 );

	    this.addEventListener( 'window-resize', this.onWindowResize );

	}

	LittlePlanet.prototype = Object.assign( Object.create( ImagePanorama.prototype ), {

	    constructor: LittlePlanet,

	    add: function ( object ) {

	        if ( arguments.length > 1 ) {
				
	            for ( let i = 0; i < arguments.length; i ++ ) {

	                this.add( arguments[ i ] );

	            }

	            return this;

	        }

	        if ( object instanceof Infospot ) {

	            object.material.depthTest = false;
				
	        }

	        ImagePanorama.prototype.add.call( this, object );

	    },

	    createGeometry: function ( size, ratio ) {

	        return new THREE.PlaneBufferGeometry( size, size * ratio );

	    },

	    createMaterial: function ( size ) {

	        const shader = Object.assign( {}, StereographicShader ), uniforms = shader.uniforms;

	        uniforms.zoom.value = size;
	        uniforms.opacity.value = 0.0;

	        return new THREE.ShaderMaterial( {

	            uniforms: uniforms,
	            vertexShader: shader.vertexShader,
	            fragmentShader: shader.fragmentShader,
	            side: THREE.BackSide,
	            transparent: true

	        } );
			
	    },

	    registerMouseEvents: function () {

	        this.container.addEventListener( 'mousedown', this.onMouseDown.bind( this ), { passive: true } );
	        this.container.addEventListener( 'mousemove', this.onMouseMove.bind( this ), { passive: true } );
	        this.container.addEventListener( 'mouseup', this.onMouseUp.bind( this ), { passive: true } );
	        this.container.addEventListener( 'touchstart', this.onMouseDown.bind( this ), { passive: true } );
	        this.container.addEventListener( 'touchmove', this.onMouseMove.bind( this ), { passive: true } );
	        this.container.addEventListener( 'touchend', this.onMouseUp.bind( this ), { passive: true } );
	        this.container.addEventListener( 'mousewheel', this.onMouseWheel.bind( this ), { passive: false } );
	        this.container.addEventListener( 'DOMMouseScroll', this.onMouseWheel.bind( this ), { passive: false } );
	        this.container.addEventListener( 'contextmenu', this.onContextMenu.bind( this ), { passive: true } );
			
	    },

	    unregisterMouseEvents: function () {

	        this.container.removeEventListener( 'mousedown', this.onMouseDown.bind( this ), false );
	        this.container.removeEventListener( 'mousemove', this.onMouseMove.bind( this ), false );
	        this.container.removeEventListener( 'mouseup', this.onMouseUp.bind( this ), false );
	        this.container.removeEventListener( 'touchstart', this.onMouseDown.bind( this ), false );
	        this.container.removeEventListener( 'touchmove', this.onMouseMove.bind( this ), false );
	        this.container.removeEventListener( 'touchend', this.onMouseUp.bind( this ), false );
	        this.container.removeEventListener( 'mousewheel', this.onMouseWheel.bind( this ), false );
	        this.container.removeEventListener( 'DOMMouseScroll', this.onMouseWheel.bind( this ), false );
	        this.container.removeEventListener( 'contextmenu', this.onContextMenu.bind( this ), false );
			
	    },

	    onMouseDown: function ( event ) {
	        const inputCount = ( event.touches && event.touches.length ) || 1 ;

	        switch ( inputCount ) {

	        case 1:

	            const x = ( event.clientX >= 0 ) ? event.clientX : event.touches[ 0 ].clientX;
	            const y = ( event.clientY >= 0 ) ? event.clientY : event.touches[ 0 ].clientY;

	            this.dragging = true;
	            this.userMouse.set( x, y );

	            break;

	        case 2:

	            const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
	            const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	            const distance = Math.sqrt( dx * dx + dy * dy );
	            this.userMouse.pinchDistance = distance;

	            break;

	        default:

	            break;

	        }

	        this.onUpdateCallback();

	    },

	    onMouseMove: function ( event ) {

	        const inputCount = ( event.touches && event.touches.length ) || 1 ;

	        switch ( inputCount ) {

	        case 1:

	            const x = ( event.clientX >= 0 ) ? event.clientX : event.touches[ 0 ].clientX;
	            const y = ( event.clientY >= 0 ) ? event.clientY : event.touches[ 0 ].clientY;

	            const angleX = THREE.Math.degToRad( x - this.userMouse.x ) * 0.4;
	            const angleY = THREE.Math.degToRad( y - this.userMouse.y ) * 0.4;

	            if ( this.dragging ) {
	                this.quatA.setFromAxisAngle( this.vectorY, angleX );
	                this.quatB.setFromAxisAngle( this.vectorX, angleY );
	                this.quatCur.multiply( this.quatA ).multiply( this.quatB );
	                this.userMouse.set( x, y );
	            }

	            break;

	        case 2:

	            const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
	            const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	            const distance = Math.sqrt( dx * dx + dy * dy );

	            this.addZoomDelta( this.userMouse.pinchDistance - distance );

	            break;

	        default:

	            break;

	        }

	    },

	    onMouseUp: function () {

	        this.dragging = false;

	    },

	    onMouseWheel: function ( event ) {

	        event.preventDefault();
	        event.stopPropagation();

	        let delta = 0;

	        if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9

	            delta = event.wheelDelta;

	        } else if ( event.detail !== undefined ) { // Firefox

	            delta = - event.detail;

	        }

	        this.addZoomDelta( delta );
	        this.onUpdateCallback();

	    },

	    addZoomDelta: function ( delta ) {

	        const uniforms = this.material.uniforms;
	        const lowerBound = this.size * 0.1;
	        const upperBound = this.size * 10;

	        uniforms.zoom.value += delta;

	        if ( uniforms.zoom.value <= lowerBound ) {

	            uniforms.zoom.value = lowerBound;

	        } else if ( uniforms.zoom.value >= upperBound ) {

	            uniforms.zoom.value = upperBound;

	        }

	    },

	    onUpdateCallback: function () {

	        this.frameId = window.requestAnimationFrame( this.onUpdateCallback.bind( this ) );

	        this.quatSlerp.slerp( this.quatCur, 0.1 );

	        if ( this.material ) {

	            this.material.uniforms.transform.value.makeRotationFromQuaternion( this.quatSlerp );

	        }
	        
	        if ( !this.dragging && 1.0 - this.quatSlerp.clone().dot( this.quatCur ) < this.EPS ) {
				
	            window.cancelAnimationFrame( this.frameId );

	        }

	    },

	    reset: function () {

	        this.quatCur.set( 0, 0, 0, 1 );
	        this.quatSlerp.set( 0, 0, 0, 1 );
	        this.onUpdateCallback();

	    },

	    onLoad: function ( texture ) {

	        this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight;

	        this.registerMouseEvents();
	        this.onUpdateCallback();
			
	        this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'disableControl' } );

	        ImagePanorama.prototype.onLoad.call( this, texture );
			
	    },

	    onLeave: function () {

	        this.unregisterMouseEvents();

	        this.dispatchEvent( { type: 'panolens-viewer-handler', method: 'enableControl', data: CONTROLS.ORBIT } );

	        window.cancelAnimationFrame( this.frameId );

	        ImagePanorama.prototype.onLeave.call( this );
			
	    },

	    onWindowResize: function () {

	        this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight;

	    },

	    onContextMenu: function () {

	        this.dragging = false;

	    },

	    dispose: function () {	

	        this.unregisterMouseEvents();

	        ImagePanorama.prototype.dispose.call( this );

	    }

	});

	/**
	 * @classdesc Image Little Planet
	 * @constructor
	 * @param {string} source 		- URL for the image source
	 * @param {number} [size=10000] - Size of plane geometry
	 * @param {number} [ratio=0.5]  - Ratio of plane geometry's height against width
	 */
	function ImageLittlePlanet ( source, size, ratio ) {

	    LittlePlanet.call( this, 'image', source, size, ratio );

	}

	ImageLittlePlanet.prototype = Object.assign( Object.create( LittlePlanet.prototype ), {

	    constructor: ImageLittlePlanet,

	    /**
	     * On loaded with texture
	     * @param {THREE.Texture} texture
	     * @memberOf ImageLittlePlanet
	     * @instance
	     */
	    onLoad: function ( texture ) {

	        this.updateTexture( texture );

	        LittlePlanet.prototype.onLoad.call( this, texture );

	    },
	    
	    /**
	     * Update texture
	     * @param {THREE.Texture} texture 
	     * @memberOf ImageLittlePlanet
	     * @instance
	     */
	    updateTexture: function ( texture ) {

	        texture.minFilter = texture.magFilter = THREE.LinearFilter;
			
	        this.material.uniforms[ 'tDiffuse' ].value = texture;

	    },

	    /**
	     * Dispose
	     * @memberOf ImageLittlePlanet
	     * @instance
	     */
	    dispose: function () {

	        const tDiffuse = this.material.uniforms[ 'tDiffuse' ];

	        if ( tDiffuse && tDiffuse.value ) {

	            tDiffuse.value.dispose();

	        }

	        LittlePlanet.prototype.dispose.call( this );

	    }

	} );

	/**
	 * @classdesc Camera panorama
	 * @description See {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints|MediaStreamConstraints} for constraints
	 * @param {object} - camera constraints
	 * @constructor
	 */
	function CameraPanorama ( constraints ) {

	    const radius = 5000;
	    const geometry = new THREE.SphereBufferGeometry( radius, 60, 40 );
	    const material = new THREE.MeshBasicMaterial( { visible: false });

	    Panorama.call( this, geometry, material );

	    this.media = new Media( constraints );
	    this.radius = radius;

	    this.addEventListener( 'enter', this.start.bind( this ) );
	    this.addEventListener( 'leave', this.stop.bind( this ) );
	    this.addEventListener( 'panolens-container', this.onPanolensContainer.bind( this ) );
	    this.addEventListener( 'panolens-scene', this.onPanolensScene.bind( this ) );

	}

	CameraPanorama.prototype = Object.assign( Object.create( Panorama.prototype ), {

	    constructor: CameraPanorama,

	    /**
	     * On container event
	     * @param {object} event
	     * @memberOf CameraPanorama
	     * @instance
	     */
	    onPanolensContainer: function ( { container } ) {

	        this.media.setContainer( container );

	    },

	    /**
	     * On scene event
	     * @param {object} event 
	     * @memberOf CameraPanorama
	     * @instance
	     */
	    onPanolensScene: function ( { scene } ) {

	        this.media.setScene( scene );

	    },

	    /**
	     * Start camera streaming
	     * @memberOf CameraPanorama
	     * @instance
	     * @returns {Promise}
	     */
	    start: function () {

	        return this.media.start();

	    },

	    /**
	     * Stop camera streaming
	     * @memberOf CameraPanorama
	     * @instance
	     */
	    stop: function () {

	        this.media.stop();

	    },

	} );

	/**
	 * @classdesc Orbit Controls
	 * @constructor
	 * @external OrbitControls
	 * @param {THREE.Object} object 
	 * @param {HTMLElement} domElement 
	 */
	function OrbitControls ( object, domElement ) {

	    this.object = object;
	    this.domElement = ( domElement !== undefined ) ? domElement : document;
	    this.frameId = null;

	    // API

	    // Set to false to disable this control
	    this.enabled = true;

	    /*
	     * "target" sets the location of focus, where the control orbits around
	     * and where it pans with respect to.
	     */
	    this.target = new THREE.Vector3();

	    // center is old, deprecated; use "target" instead
	    this.center = this.target;

	    /*
	     * This option actually enables dollying in and out; left as "zoom" for
	     * backwards compatibility
	     */
	    this.noZoom = false;
	    this.zoomSpeed = 1.0;

	    // Limits to how far you can dolly in and out ( PerspectiveCamera only )
	    this.minDistance = 0;
	    this.maxDistance = Infinity;

	    // Limits to how far you can zoom in and out ( OrthographicCamera only )
	    this.minZoom = 0;
	    this.maxZoom = Infinity;

	    // Set to true to disable this control
	    this.noRotate = false;
	    this.rotateSpeed = -0.15;

	    // Set to true to disable this control
	    this.noPan = true;
	    this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	    // Set to true to automatically rotate around the target
	    this.autoRotate = false;
	    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	    /*
	     * How far you can orbit vertically, upper and lower limits.
	     * Range is 0 to Math.PI radians.
	     */
	    this.minPolarAngle = 0; // radians
	    this.maxPolarAngle = Math.PI; // radians

	    // Momentum
	  	this.momentumDampingFactor = 0.90;
	  	this.momentumScalingFactor = -0.005;
	  	this.momentumKeydownFactor = 20;

	  	// Fov
	  	this.minFov = 30;
	  	this.maxFov = 120;

	    /*
	     * How far you can orbit horizontally, upper and lower limits.
	     * If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	     */
	    this.minAzimuthAngle = - Infinity; // radians
	    this.maxAzimuthAngle = Infinity; // radians

	    // Set to true to disable use of the keys
	    this.noKeys = false;

	    // The four arrow keys
	    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	    // Mouse buttons
	    this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	    /*
	     * //////////
	     * internals
	     */

	    var scope = this;

	    var EPS = 10e-8;
	    var MEPS = 10e-5;

	    var rotateStart = new THREE.Vector2();
	    var rotateEnd = new THREE.Vector2();
	    var rotateDelta = new THREE.Vector2();

	    var panStart = new THREE.Vector2();
	    var panEnd = new THREE.Vector2();
	    var panDelta = new THREE.Vector2();
	    var panOffset = new THREE.Vector3();

	    var offset = new THREE.Vector3();

	    var dollyStart = new THREE.Vector2();
	    var dollyEnd = new THREE.Vector2();
	    var dollyDelta = new THREE.Vector2();

	    var theta = 0;
	    var phi = 0;
	    var phiDelta = 0;
	    var thetaDelta = 0;
	    var scale = 1;
	    var pan = new THREE.Vector3();

	    var lastPosition = new THREE.Vector3();
	    var lastQuaternion = new THREE.Quaternion();

	    var momentumLeft = 0, momentumUp = 0;
	    var eventPrevious;
	    var momentumOn = false;

	    var keyUp, keyBottom, keyLeft, keyRight;

	    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	    var state = STATE.NONE;

	    // for reset

	    this.target0 = this.target.clone();
	    this.position0 = this.object.position.clone();
	    this.zoom0 = this.object.zoom;

	    // so camera.up is the orbit axis

	    var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
	    var quatInverse = quat.clone().inverse();

	    // events

	    var changeEvent = { type: 'change' };
	    var startEvent = { type: 'start' };
	    var endEvent = { type: 'end' };

	    this.setLastQuaternion = function ( quaternion ) {
	        lastQuaternion.copy( quaternion );
	        scope.object.quaternion.copy( quaternion );
	    };

	    this.getLastPosition = function () {
	        return lastPosition;
	    };

	    this.rotateLeft = function ( angle ) {

	        if ( angle === undefined ) {

	            angle = getAutoRotationAngle();

	        }

	        thetaDelta -= angle;


	    };

	    this.rotateUp = function ( angle ) {

	        if ( angle === undefined ) {

	            angle = getAutoRotationAngle();

	        }

	        phiDelta -= angle;

	    };

	    // pass in distance in world space to move left
	    this.panLeft = function ( distance ) {

	        var te = this.object.matrix.elements;

	        // get X column of matrix
	        panOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );
	        panOffset.multiplyScalar( - distance );

	        pan.add( panOffset );

	    };

	    // pass in distance in world space to move up
	    this.panUp = function ( distance ) {

	        var te = this.object.matrix.elements;

	        // get Y column of matrix
	        panOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );
	        panOffset.multiplyScalar( distance );

	        pan.add( panOffset );

	    };

	    /*
	     * pass in x,y of change desired in pixel space,
	     * right and down are positive
	     */
	    this.pan = function ( deltaX, deltaY ) {

	        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	        if ( scope.object instanceof THREE.PerspectiveCamera ) {

	            // perspective
	            var position = scope.object.position;
	            var offset = position.clone().sub( scope.target );
	            var targetDistance = offset.length();

	            // half of the fov is center to top of screen
	            targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

	            // we actually don't use screenWidth, since perspective camera is fixed to screen height
	            scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );
	            scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );

	        } else if ( scope.object instanceof THREE.OrthographicCamera ) {

	            // orthographic
	            scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );
	            scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );

	        } else {

	            // camera neither orthographic or perspective
	            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

	        }

	    };

	    this.momentum = function(){
			
	        if ( !momentumOn ) return;

	        if ( Math.abs( momentumLeft ) < MEPS && Math.abs( momentumUp ) < MEPS ) { 

	            momentumOn = false; 
	            return;
	        }

	        momentumUp   *= this.momentumDampingFactor;
	        momentumLeft *= this.momentumDampingFactor;

	        thetaDelta -= this.momentumScalingFactor * momentumLeft;
	        phiDelta   -= this.momentumScalingFactor * momentumUp;

	    };

	    this.dollyIn = function ( dollyScale ) {

	        if ( dollyScale === undefined ) {

	            dollyScale = getZoomScale();

	        }

	        if ( scope.object instanceof THREE.PerspectiveCamera ) {

	            scale /= dollyScale;

	        } else if ( scope.object instanceof THREE.OrthographicCamera ) {

	            scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );
	            scope.object.updateProjectionMatrix();
	            scope.dispatchEvent( changeEvent );

	        } else {

	            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );

	        }

	    };

	    this.dollyOut = function ( dollyScale ) {

	        if ( dollyScale === undefined ) {

	            dollyScale = getZoomScale();

	        }

	        if ( scope.object instanceof THREE.PerspectiveCamera ) {

	            scale *= dollyScale;

	        } else if ( scope.object instanceof THREE.OrthographicCamera ) {

	            scope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );
	            scope.object.updateProjectionMatrix();
	            scope.dispatchEvent( changeEvent );

	        } else {

	            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );

	        }

	    };

	    this.update = function ( ignoreUpdate ) {

	        var position = this.object.position;

	        offset.copy( position ).sub( this.target );

	        // rotate offset to "y-axis-is-up" space
	        offset.applyQuaternion( quat );

	        // angle from z-axis around y-axis

	        theta = Math.atan2( offset.x, offset.z );

	        // angle from y-axis

	        phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

	        if ( this.autoRotate && state === STATE.NONE ) {

	            this.rotateLeft( getAutoRotationAngle() );

	        }

	        this.momentum();

	        theta += thetaDelta;
	        phi += phiDelta;

	        // restrict theta to be between desired limits
	        theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );

	        // restrict phi to be between desired limits
	        phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

	        // restrict phi to be betwee EPS and PI-EPS
	        phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

	        var radius = offset.length() * scale;

	        // restrict radius to be between desired limits
	        radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

	        // move target to panned location
	        this.target.add( pan );

	        offset.x = radius * Math.sin( phi ) * Math.sin( theta );
	        offset.y = radius * Math.cos( phi );
	        offset.z = radius * Math.sin( phi ) * Math.cos( theta );

	        // rotate offset back to "camera-up-vector-is-up" space
	        offset.applyQuaternion( quatInverse );

	        position.copy( this.target ).add( offset );

	        this.object.lookAt( this.target );

	        thetaDelta = 0;
	        phiDelta = 0;
	        scale = 1;
	        pan.set( 0, 0, 0 );

	        /*
	         * update condition is:
	         * min(camera displacement, camera rotation in radians)^2 > EPS
	         * using small-angle approximation cos(x/2) = 1 - x^2 / 8
	         */
	        if ( lastPosition.distanceToSquared( this.object.position ) > EPS
			    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {

	            if ( ignoreUpdate !== true ) { this.dispatchEvent( changeEvent ); }

	            lastPosition.copy( this.object.position );
	            lastQuaternion.copy (this.object.quaternion );

	        }

	    };


	    this.reset = function () {

	        state = STATE.NONE;

	        this.target.copy( this.target0 );
	        this.object.position.copy( this.position0 );
	        this.object.zoom = this.zoom0;

	        this.object.updateProjectionMatrix();
	        this.dispatchEvent( changeEvent );

	        this.update();

	    };

	    this.getPolarAngle = function () {

	        return phi;

	    };

	    this.getAzimuthalAngle = function () {

	        return theta;

	    };

	    function getAutoRotationAngle() {

	        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	    }

	    function getZoomScale() {

	        return Math.pow( 0.95, scope.zoomSpeed );

	    }

	    function onMouseDown( event ) {

	        momentumOn = false;

	   		momentumLeft = momentumUp = 0;

	        if ( scope.enabled === false ) return;
	        event.preventDefault();

	        if ( event.button === scope.mouseButtons.ORBIT ) {
	            if ( scope.noRotate === true ) return;

	            state = STATE.ROTATE;

	            rotateStart.set( event.clientX, event.clientY );

	        } else if ( event.button === scope.mouseButtons.ZOOM ) {
	            if ( scope.noZoom === true ) return;

	            state = STATE.DOLLY;

	            dollyStart.set( event.clientX, event.clientY );

	        } else if ( event.button === scope.mouseButtons.PAN ) {
	            if ( scope.noPan === true ) return;

	            state = STATE.PAN;

	            panStart.set( event.clientX, event.clientY );

	        }

	        if ( state !== STATE.NONE ) {
	            document.addEventListener( 'mousemove', onMouseMove, false );
	            document.addEventListener( 'mouseup', onMouseUp, false );
	            scope.dispatchEvent( startEvent );
	        }

	        scope.update();

	    }

	    function onMouseMove( event ) {

	        if ( scope.enabled === false ) return;

	        event.preventDefault();

	        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	        if ( state === STATE.ROTATE ) {

	            if ( scope.noRotate === true ) return;

	            rotateEnd.set( event.clientX, event.clientY );
	            rotateDelta.subVectors( rotateEnd, rotateStart );

	            // rotating across whole screen goes 360 degrees around
	            scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

	            // rotating up and down along whole screen attempts to go 360, but limited to 180
	            scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

	            rotateStart.copy( rotateEnd );

	            if( eventPrevious ){
	                momentumLeft = event.clientX - eventPrevious.clientX;
	                momentumUp = event.clientY - eventPrevious.clientY;
	            }

	            eventPrevious = event;

	        } else if ( state === STATE.DOLLY ) {

	            if ( scope.noZoom === true ) return;

	            dollyEnd.set( event.clientX, event.clientY );
	            dollyDelta.subVectors( dollyEnd, dollyStart );

	            if ( dollyDelta.y > 0 ) {

	                scope.dollyIn();

	            } else if ( dollyDelta.y < 0 ) {

	                scope.dollyOut();

	            }

	            dollyStart.copy( dollyEnd );

	        } else if ( state === STATE.PAN ) {

	            if ( scope.noPan === true ) return;

	            panEnd.set( event.clientX, event.clientY );
	            panDelta.subVectors( panEnd, panStart );

	            scope.pan( panDelta.x, panDelta.y );

	            panStart.copy( panEnd );

	        }

	        if ( state !== STATE.NONE ) scope.update();

	    }

	    function onMouseUp( /* event */ ) {

	        momentumOn = true;

	        eventPrevious = undefined;

	        if ( scope.enabled === false ) return;

	        document.removeEventListener( 'mousemove', onMouseMove, false );
	        document.removeEventListener( 'mouseup', onMouseUp, false );
	        scope.dispatchEvent( endEvent );
	        state = STATE.NONE;

	    }

	    function onMouseWheel( event ) {

	        if ( scope.enabled === false || scope.noZoom === true || state !== STATE.NONE ) return;

	        event.preventDefault();
	        event.stopPropagation();

	        var delta = 0;

	        if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9

	            delta = event.wheelDelta;

	        } else if ( event.detail !== undefined ) { // Firefox

	            delta = - event.detail;

	        }

	        if ( delta > 0 ) {

	            // scope.dollyOut();
	            scope.object.fov = ( scope.object.fov < scope.maxFov ) 
	                ? scope.object.fov + 1
	                : scope.maxFov;
	            scope.object.updateProjectionMatrix();

	        } else if ( delta < 0 ) {

	            // scope.dollyIn();
	            scope.object.fov = ( scope.object.fov > scope.minFov ) 
	                ? scope.object.fov - 1
	                : scope.minFov;
	            scope.object.updateProjectionMatrix();

	        }

	        scope.update();
	        scope.dispatchEvent( changeEvent );
	        scope.dispatchEvent( startEvent );
	        scope.dispatchEvent( endEvent );

	    }

	    function onKeyUp ( event ) {

	        switch ( event.keyCode ) {

	        case scope.keys.UP:
	            keyUp = false;
	            break;

	        case scope.keys.BOTTOM:
	            keyBottom = false;
	            break;

	        case scope.keys.LEFT:
	            keyLeft = false;
	            break;

	        case scope.keys.RIGHT:
	            keyRight = false;
	            break;

	        }

	    }

	    function onKeyDown( event ) {

	        if ( scope.enabled === false || scope.noKeys === true || scope.noRotate === true ) return;

	        switch ( event.keyCode ) {

	        case scope.keys.UP:
	            keyUp = true;
	            break;

	        case scope.keys.BOTTOM:
	            keyBottom = true;
	            break;

	        case scope.keys.LEFT:
	            keyLeft = true;
	            break;

	        case scope.keys.RIGHT:
	            keyRight = true;
	            break;

	        }

	        if (keyUp || keyBottom || keyLeft || keyRight) {

	            momentumOn = true;

	            if (keyUp) momentumUp = - scope.rotateSpeed * scope.momentumKeydownFactor;
	            if (keyBottom) momentumUp = scope.rotateSpeed * scope.momentumKeydownFactor;
	            if (keyLeft) momentumLeft = - scope.rotateSpeed * scope.momentumKeydownFactor;
	            if (keyRight) momentumLeft = scope.rotateSpeed * scope.momentumKeydownFactor;

	        }

	    }

	    function touchstart( event ) {
	        momentumOn = false;

	        momentumLeft = momentumUp = 0;

	        if ( scope.enabled === false ) return;

	        switch ( event.touches.length ) {

	        case 1:	// one-fingered touch: rotate

	            if ( scope.noRotate === true ) return;

	            state = STATE.TOUCH_ROTATE;

	            rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	            break;

	        case 2:	// two-fingered touch: dolly

	            if ( scope.noZoom === true ) return;

	            state = STATE.TOUCH_DOLLY;

	            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
	            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	            var distance = Math.sqrt( dx * dx + dy * dy );

	            dollyStart.set( 0, distance );

	            break;

	        case 3: // three-fingered touch: pan

	            if ( scope.noPan === true ) return;

	            state = STATE.TOUCH_PAN;

	            panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	            break;

	        default:

	            state = STATE.NONE;

	        }

	        if ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );

	    }

	    function touchmove( event ) {

	        if ( scope.enabled === false ) return;

	        event.preventDefault();
	        event.stopPropagation();

	        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	        switch ( event.touches.length ) {

	        case 1: // one-fingered touch: rotate

	            if ( scope.noRotate === true ) return;
	            if ( state !== STATE.TOUCH_ROTATE ) return;

	            rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	            rotateDelta.subVectors( rotateEnd, rotateStart );

	            // rotating across whole screen goes 360 degrees around
	            scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
	            // rotating up and down along whole screen attempts to go 360, but limited to 180
	            scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

	            rotateStart.copy( rotateEnd );

	            if( eventPrevious ){
	                momentumLeft = event.touches[ 0 ].pageX - eventPrevious.pageX;
	                momentumUp = event.touches[ 0 ].pageY - eventPrevious.pageY;
	            }

	            eventPrevious = {
	                pageX: event.touches[ 0 ].pageX,
	                pageY: event.touches[ 0 ].pageY,
	            };

	            scope.update();
	            break;

	        case 2: // two-fingered touch: dolly

	            if ( scope.noZoom === true ) return;
	            if ( state !== STATE.TOUCH_DOLLY ) return;

	            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
	            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	            var distance = Math.sqrt( dx * dx + dy * dy );

	            dollyEnd.set( 0, distance );
	            dollyDelta.subVectors( dollyEnd, dollyStart );

	            if ( dollyDelta.y < 0 ) {

	                scope.object.fov = ( scope.object.fov < scope.maxFov ) 
	                    ? scope.object.fov + 1
	                    : scope.maxFov;
	                scope.object.updateProjectionMatrix();

	            } else if ( dollyDelta.y > 0 ) {

	                scope.object.fov = ( scope.object.fov > scope.minFov ) 
	                    ? scope.object.fov - 1
	                    : scope.minFov;
	                scope.object.updateProjectionMatrix();

	            }

	            dollyStart.copy( dollyEnd );

	            scope.update();
	            scope.dispatchEvent( changeEvent );
	            break;

	        case 3: // three-fingered touch: pan

	            if ( scope.noPan === true ) return;
	            if ( state !== STATE.TOUCH_PAN ) return;

	            panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	            panDelta.subVectors( panEnd, panStart );

	            scope.pan( panDelta.x, panDelta.y );

	            panStart.copy( panEnd );

	            scope.update();
	            break;

	        default:

	            state = STATE.NONE;

	        }

	    }

	    function touchend( /* event */ ) {

	        momentumOn = true;

	        eventPrevious = undefined;

	        if ( scope.enabled === false ) return;

	        scope.dispatchEvent( endEvent );
	        state = STATE.NONE;

	    }

	    this.dispose = function() {

	        this.domElement.removeEventListener( 'mousedown', onMouseDown );
	        this.domElement.removeEventListener( 'mousewheel', onMouseWheel );
	        this.domElement.removeEventListener( 'DOMMouseScroll', onMouseWheel );

	        this.domElement.removeEventListener( 'touchstart', touchstart );
	        this.domElement.removeEventListener( 'touchend', touchend );
	        this.domElement.removeEventListener( 'touchmove', touchmove );

	        window.removeEventListener( 'keyup', onKeyUp );
	        window.removeEventListener( 'keydown', onKeyDown );

	    };

	    // this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
	    this.domElement.addEventListener( 'mousedown', onMouseDown, { passive: false } );
	    this.domElement.addEventListener( 'mousewheel', onMouseWheel, { passive: false } );
	    this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, { passive: false } ); // firefox

	    this.domElement.addEventListener( 'touchstart', touchstart, { passive: false } );
	    this.domElement.addEventListener( 'touchend', touchend, { passive: false } );
	    this.domElement.addEventListener( 'touchmove', touchmove, { passive: false } );

	    window.addEventListener( 'keyup', onKeyUp, { passive: false } );
	    window.addEventListener( 'keydown', onKeyDown, { passive: false } );

	    // force an update at start
	    this.update();

	}
	OrbitControls.prototype = Object.assign( Object.create( THREE.EventDispatcher.prototype ), {

	    constructor: OrbitControls

	} );

	/**
	 * @classdesc Device Orientation Control
	 * @constructor
	 * @external DeviceOrientationControls
	 * @param {THREE.Camera} camera 
	 * @param {HTMLElement} domElement 
	 */
	function DeviceOrientationControls ( camera, domElement ) {

	    var scope = this;
	    var changeEvent = { type: 'change' };

	    var rotY = 0;
	    var rotX = 0;
	    var tempX = 0;
	    var tempY = 0;

	    this.camera = camera;
	    this.camera.rotation.reorder( 'YXZ' );
	    this.domElement = ( domElement !== undefined ) ? domElement : document;

	    this.enabled = true;

	    this.deviceOrientation = {};
	    this.screenOrientation = 0;

	    this.alpha = 0;
	    this.alphaOffsetAngle = 0;
		var isFromHere = false;


	    var onDeviceOrientationChangeEvent = function( event ) {

	        scope.deviceOrientation = event;

	    };

	    var onScreenOrientationChangeEvent = function() {
			if(window.orientation == 0)
			{
				if(mobileOperatingSystem != "iOS" && isFullscreen == true && shipDeck.viewer != null)
				{
					shipDeck.viewer.widget.EnableDisableFullScreen();
					isFromHere = true;
				}
			}
			/* else if(window.orientation == 90 && isFromHere == true)
			{
				if(mobileOperatingSystem != "iOS" && isFullscreen == false && shipDeck.viewer != null)
				{
					console.log("------orientation-----90-------------");
					setTimeout(function(){
						shipDeck.viewer.widget.EnableDisableFullScreen();
					}, 1000);
					isFromHere = false;
				}
			} */
			
	        scope.screenOrientation = window.orientation || 0;

	    };

	    var onTouchStartEvent = function (event) {
	        event.preventDefault();
	        event.stopPropagation();

	        tempX = event.touches[ 0 ].pageX;
	        tempY = event.touches[ 0 ].pageY;

	    };

	    var onTouchMoveEvent = function (event) {

	        event.preventDefault();
	        event.stopPropagation();

	        rotY += THREE.Math.degToRad( ( event.touches[ 0 ].pageX - tempX ) / 4 );
	        rotX += THREE.Math.degToRad( ( tempY - event.touches[ 0 ].pageY ) / 4 );

	        scope.updateAlphaOffsetAngle( rotY );

	        tempX = event.touches[ 0 ].pageX;
	        tempY = event.touches[ 0 ].pageY;

	    };

	    // The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

	    var setCameraQuaternion = function( quaternion, alpha, beta, gamma, orient ) {

	        var zee = new THREE.Vector3( 0, 0, 1 );

	        var euler = new THREE.Euler();

	        var q0 = new THREE.Quaternion();

	        var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis

	        var vectorFingerY;
	        var fingerQY = new THREE.Quaternion();
	        var fingerQX = new THREE.Quaternion();

	        if ( scope.screenOrientation == 0 ) {

	            vectorFingerY = new THREE.Vector3( 1, 0, 0 );
	            fingerQY.setFromAxisAngle( vectorFingerY, -rotX );

	        } else if ( scope.screenOrientation == 180 ) {

	            vectorFingerY = new THREE.Vector3( 1, 0, 0 );
	            fingerQY.setFromAxisAngle( vectorFingerY, rotX );

	        } else if ( scope.screenOrientation == 90 ) {

	            vectorFingerY = new THREE.Vector3( 0, 1, 0 );
	            fingerQY.setFromAxisAngle( vectorFingerY, rotX );

	        } else if ( scope.screenOrientation == - 90) {

	            vectorFingerY = new THREE.Vector3( 0, 1, 0 );
	            fingerQY.setFromAxisAngle( vectorFingerY, -rotX );

	        }

	        q1.multiply( fingerQY );
	        q1.multiply( fingerQX );

	        euler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us

	        quaternion.setFromEuler( euler ); // orient the device

	        quaternion.multiply( q1 ); // camera looks out the back of the device, not the top

	        quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) ); // adjust for screen orientation

	    };

	    this.connect = function() {

	        onScreenOrientationChangeEvent(); // run once on load

	        window.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, { passive: true } );
	        window.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, { passive: true } );
	        window.addEventListener( 'deviceorientation', this.update.bind( this ), { passive: true } );

	        scope.domElement.addEventListener( 'touchstart', onTouchStartEvent, { passive: false } );
	        scope.domElement.addEventListener( 'touchmove', onTouchMoveEvent, { passive: false } );

	        scope.enabled = true;

	    };

	    this.disconnect = function() {

	        window.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
	        window.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );
	        window.removeEventListener( 'deviceorientation', this.update.bind( this ), false );

	        scope.domElement.removeEventListener( 'touchstart', onTouchStartEvent, false );
	        scope.domElement.removeEventListener( 'touchmove', onTouchMoveEvent, false );

	        scope.enabled = false;

	    };

	    this.update = function( ignoreUpdate ) {

	        if ( scope.enabled === false ) return;

	        var alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) + scope.alphaOffsetAngle : 0; // Z
	        var beta = scope.deviceOrientation.beta ? THREE.Math.degToRad( scope.deviceOrientation.beta ) : 0; // X'
	        var gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''
	        var orient = scope.screenOrientation ? THREE.Math.degToRad( scope.screenOrientation ) : 0; // O

	        setCameraQuaternion( scope.camera.quaternion, alpha, beta, gamma, orient );
	        scope.alpha = alpha;

	        if ( ignoreUpdate !== true ) { scope.dispatchEvent( changeEvent ); }

	    };

	    this.updateAlphaOffsetAngle = function( angle ) {

	        this.alphaOffsetAngle = angle;
	        this.update();

	    };

	    this.dispose = function() {

	        this.disconnect();

	    };

	    this.connect();

	}
	DeviceOrientationControls.prototype = Object.assign( Object.create( THREE.EventDispatcher.prototype), {

	    constructor: DeviceOrientationControls

	} );

	/**
	 * @classdesc Google Cardboard Effect Composer
	 * @constructor
	 * @external CardboardEffect
	 * @param {THREE.WebGLRenderer} renderer 
	 */
	function CardboardEffect ( renderer ) {
	    var _camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

	    var _scene = new THREE.Scene();

	    var _stereo = new THREE.StereoCamera();
	    _stereo.aspect = 0.5;

	    var _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

	    var _renderTarget = new THREE.WebGLRenderTarget( 512, 512, _params );
	    _renderTarget.scissorTest = true;
	    _renderTarget.texture.generateMipmaps = false;

	    /*
	     * Distortion Mesh ported from:
	     * https://github.com/borismus/webvr-boilerplate/blob/master/src/distortion/barrel-distortion-fragment.js
	     */

	    var distortion = new THREE.Vector2( 0.441, 0.156 );

	    var geometry = new THREE.PlaneBufferGeometry( 1, 1, 10, 20 ).removeAttribute( 'normal' ).toNonIndexed();

	    var positions = geometry.attributes.position.array;
	    var uvs = geometry.attributes.uv.array;

	    // duplicate
	    geometry.attributes.position.count *= 2;
	    geometry.attributes.uv.count *= 2;

	    var positions2 = new Float32Array( positions.length * 2 );
	    positions2.set( positions );
	    positions2.set( positions, positions.length );

	    var uvs2 = new Float32Array( uvs.length * 2 );
	    uvs2.set( uvs );
	    uvs2.set( uvs, uvs.length );

	    var vector = new THREE.Vector2();
	    var length = positions.length / 3;

	    for ( var i = 0, l = positions2.length / 3; i < l; i ++ ) {

	        vector.x = positions2[ i * 3 + 0 ];
	        vector.y = positions2[ i * 3 + 1 ];

	        var dot = vector.dot( vector );
	        var scalar = 1.5 + ( distortion.x + distortion.y * dot ) * dot;

	        var offset = i < length ? 0 : 1;

	        positions2[ i * 3 + 0 ] = ( vector.x / scalar ) * 1.5 - 0.5 + offset;
	        positions2[ i * 3 + 1 ] = ( vector.y / scalar ) * 3.0;

	        uvs2[ i * 2 ] = ( uvs2[ i * 2 ] + offset ) * 0.5;

	    }

	    geometry.attributes.position.array = positions2;
	    geometry.attributes.uv.array = uvs2;

	    //

	    var material = new THREE.MeshBasicMaterial( { map: _renderTarget.texture } );
	    var mesh = new THREE.Mesh( geometry, material );
	    _scene.add( mesh );

	    //

	    this.setSize = function ( width, height ) {

	        renderer.setSize( width, height );

	        var pixelRatio = renderer.getPixelRatio();

	        _renderTarget.setSize( width * pixelRatio, height * pixelRatio );

	    };

	    this.render = function ( scene, camera ) {

	        scene.updateMatrixWorld();

	        if ( camera.parent === null ) camera.updateMatrixWorld();

	        _stereo.update( camera );

	        var width = _renderTarget.width / 2;
	        var height = _renderTarget.height;

	        if ( renderer.autoClear ) renderer.clear();

	        _renderTarget.scissor.set( 0, 0, width, height );
	        _renderTarget.viewport.set( 0, 0, width, height );
	        renderer.setRenderTarget( _renderTarget );
	        renderer.render( scene, _stereo.cameraL );

	        renderer.clearDepth();

	        _renderTarget.scissor.set( width, 0, width, height );
	        _renderTarget.viewport.set( width, 0, width, height );
	        renderer.setRenderTarget( _renderTarget );
	        renderer.render( scene, _stereo.cameraR );

	        renderer.clearDepth();

	        renderer.setRenderTarget( null );
	        renderer.render( _scene, _camera );
	    };

	}

	/**
	 * @classdesc Stereo Effect Composer
	 * @constructor
	 * @external StereoEffect
	 * @param {THREE.WebGLRenderer} renderer 
	 */
	const StereoEffect = function ( renderer ) {

	    var _stereo = new THREE.StereoCamera();
	    _stereo.aspect = 0.5;
	    var size = new THREE.Vector2();

	    this.setEyeSeparation = function ( eyeSep ) {

	        _stereo.eyeSep = eyeSep;

	    };

	    this.setSize = function ( width, height ) {

	        renderer.setSize( width, height );

	    };

	    this.render = function ( scene, camera ) {

	        scene.updateMatrixWorld();

	        if ( camera.parent === null ) camera.updateMatrixWorld();

	        _stereo.update( camera );

	        renderer.getSize( size );

	        if ( renderer.autoClear ) renderer.clear();
	        renderer.setScissorTest( true );

	        renderer.setScissor( 0, 0, size.width / 2, size.height );
	        renderer.setViewport( 0, 0, size.width / 2, size.height );
	        renderer.render( scene, _stereo.cameraL );

	        renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );
	        renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );
	        renderer.render( scene, _stereo.cameraR );

	        renderer.setScissorTest( false );

	    };

	};

	/**
	 * @classdesc Viewer contains pre-defined scene, camera and renderer
	 * @constructor
	 * @param {object} [options] - Use custom or default config options
	 * @param {HTMLElement} [options.container] - A HTMLElement to host the canvas
	 * @param {THREE.Scene} [options.scene=THREE.Scene] - A THREE.Scene which contains panorama and 3D objects
	 * @param {THREE.Camera} [options.camera=THREE.PerspectiveCamera] - A THREE.Camera to view the scene
	 * @param {THREE.WebGLRenderer} [options.renderer=THREE.WebGLRenderer] - A THREE.WebGLRenderer to render canvas
	 * @param {boolean} [options.controlBar=true] - Show/hide control bar on the bottom of the container
	 * @param {array}   [options.controlButtons=[]] - Button names to mount on controlBar if controlBar exists, Defaults to ['fullscreen', 'setting', 'video']
	 * @param {boolean} [options.autoHideControlBar=false] - Auto hide control bar when click on non-active area
	 * @param {boolean} [options.autoHideInfospot=true] - Auto hide infospots when click on non-active area
	 * @param {boolean} [options.horizontalView=false] - Allow only horizontal camera control
	 * @param {number}  [options.clickTolerance=10] - Distance tolerance to tigger click / tap event
	 * @param {number}  [options.cameraFov=60] - Camera field of view value
	 * @param {boolean} [options.reverseDragging=false] - Reverse dragging direction
	 * @param {boolean} [options.enableReticle=false] - Enable reticle for mouseless interaction other than VR mode
	 * @param {number}  [options.dwellTime=1500] - Dwell time for reticle selection in ms
	 * @param {boolean} [options.autoReticleSelect=true] - Auto select a clickable target after dwellTime
	 * @param {boolean} [options.viewIndicator=false] - Adds an angle view indicator in upper left corner
	 * @param {number}  [options.indicatorSize=30] - Size of View Indicator
	 * @param {string}  [options.output='none'] - Whether and where to output raycast position. Could be 'console' or 'overlay'
	 * @param {boolean} [options.autoRotate=false] - Auto rotate
	 * @param {number}  [options.autoRotateSpeed=2.0] - Auto rotate speed as in degree per second. Positive is counter-clockwise and negative is clockwise.
	 * @param {number}  [options.autoRotateActivationDuration=5000] - Duration before auto rotatation when no user interactivity in ms
	 */
	function Viewer ( options ) {

	    let container;

	    options = options || {};
	    options.controlBar = options.controlBar !== undefined ? options.controlBar : true;
	    options.controlButtons = options.controlButtons || [ 'fullscreen', 'setting', 'video' , 'close' , 'next' , 'prev' ];
	    options.autoHideControlBar = options.autoHideControlBar !== undefined ? options.autoHideControlBar : false;
	    options.autoHideInfospot = options.autoHideInfospot !== undefined ? options.autoHideInfospot : true;
	    options.horizontalView = options.horizontalView !== undefined ? options.horizontalView : false;
	    options.clickTolerance = options.clickTolerance || 10;
	    options.cameraFov = options.cameraFov || 60;
	    options.reverseDragging = options.reverseDragging || false;
	    options.enableReticle = options.enableReticle || false;
	    options.dwellTime = options.dwellTime || 1500;
	    options.autoReticleSelect = options.autoReticleSelect !== undefined ? options.autoReticleSelect : true;
	    options.viewIndicator = options.viewIndicator !== undefined ? options.viewIndicator : false;
	    options.indicatorSize = options.indicatorSize || 30;
	    options.output = options.output ? options.output : 'none';
	    options.autoRotate = options.autoRotate || false;
	    options.autoRotateSpeed = options.autoRotateSpeed || 2.0;
	    options.autoRotateActivationDuration = options.autoRotateActivationDuration || 5000;

	    this.options = options;

	    /*
	     * CSS Icon
	     * const styleLoader = new StyleLoader();
	     * styleLoader.inject( 'icono' );
	     */

	    // Container
	    if ( options.container ) {

	        container = options.container;
	        container._width = container.clientWidth;
	        container._height = container.clientHeight;

	    } else {

	        container = document.createElement( 'div' );
	        container.classList.add( 'panolens-container' );
	        container.style.width = '100%';
	        container.style.height = '100%';
	        container._width = window.innerWidth;
	        container._height = window.innerHeight;
	        document.body.appendChild( container );

	    }

	    this.container = container;

	    this.camera = options.camera || new THREE.PerspectiveCamera( this.options.cameraFov, this.container.clientWidth / this.container.clientHeight, 1, 10000 );
	    this.scene = options.scene || new THREE.Scene();
	    this.renderer = options.renderer || new THREE.WebGLRenderer( { alpha: true, antialias: false } );
	    this.sceneReticle = new THREE.Scene();

	    this.viewIndicatorSize = this.options.indicatorSize;

	    this.reticle = {};
	    this.tempEnableReticle = this.options.enableReticle;

	    this.mode = MODES.NORMAL;

	    this.panorama = null;
	    this.widget = null;

	    this.hoverObject = null;
	    this.infospot = null;
	    this.pressEntityObject = null;
	    this.pressObject = null;

	    this.raycaster = new THREE.Raycaster();
	    this.raycasterPoint = new THREE.Vector2();
	    this.userMouse = new THREE.Vector2();
	    this.updateCallbacks = [];
	    this.requestAnimationId = null;

	    this.cameraFrustum = new THREE.Frustum();
	    this.cameraViewProjectionMatrix = new THREE.Matrix4();

	    this.autoRotateRequestId = null;

	    this.outputDivElement = null;

	    this.touchSupported = 'ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch;

	    // Handler references
	    this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind( this );
	    this.HANDLER_MOUSE_UP = this.onMouseUp.bind( this );
	    this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind( this );
	    this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind( this );
	    this.HANDLER_KEY_DOWN = this.onKeyDown.bind( this );
	    this.HANDLER_KEY_UP = this.onKeyUp.bind( this );
	    this.HANDLER_TAP = this.onTap.bind( this, {
	        clientX: this.container.clientWidth / 2,
	        clientY: this.container.clientHeight / 2
	    } );

	    // Flag for infospot output
	    this.OUTPUT_INFOSPOT = false;

	    // Animations
	    this.tweenLeftAnimation = new Tween.Tween();
	    this.tweenUpAnimation = new Tween.Tween();

	    // Renderer
	    this.renderer.setPixelRatio( window.devicePixelRatio );
	    this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );
	    this.renderer.setClearColor( 0x000000, 0 );
	    this.renderer.autoClear = false;

	    // Append Renderer Element to container
	    this.renderer.domElement.classList.add( 'panolens-canvas' );
	    this.renderer.domElement.style.display = 'block';
	    this.renderer.domElement.style.zIndex = '10';
	    this.container.style.backgroundColor = '#000';
	    this.container.appendChild( this.renderer.domElement );

	    // Camera Controls
	    this.OrbitControls = new OrbitControls( this.camera, this.container );
	    this.OrbitControls.id = 'orbit';
	    this.OrbitControls.minDistance = 1;
	    this.OrbitControls.noPan = true;
	    this.OrbitControls.autoRotate = this.options.autoRotate;
	    this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed;

	    this.DeviceOrientationControls = new DeviceOrientationControls( this.camera, this.container );
	    this.DeviceOrientationControls.id = 'device-orientation';
	    this.DeviceOrientationControls.enabled = false;
	    this.camera.position.z = 1;

	    // Register change event if passiveRenering
	    if ( this.options.passiveRendering ) {

	        console.warn( 'passiveRendering is now deprecated' );

	    }

	    // Controls
	    this.controls = [ this.OrbitControls, this.DeviceOrientationControls ];
	    this.control = this.OrbitControls;

	    // Cardboard effect
	    this.CardboardEffect = new CardboardEffect( this.renderer );
	    this.CardboardEffect.setSize( this.container.clientWidth, this.container.clientHeight );

	    // Stereo effect
	    this.StereoEffect = new StereoEffect( this.renderer );
	    this.StereoEffect.setSize( this.container.clientWidth, this.container.clientHeight );

	    this.effect = this.CardboardEffect;

	    // Add default hidden reticle
	    this.addReticle();

	    // Lock horizontal view
	    if ( this.options.horizontalView ) {
	        this.OrbitControls.minPolarAngle = Math.PI / 2;
	        this.OrbitControls.maxPolarAngle = Math.PI / 2;
	    }

	    // Add Control UI
	    if ( this.options.controlBar !== false ) {
	        this.addDefaultControlBar( this.options.controlButtons );
	    }

	    // Add View Indicator
	    if ( this.options.viewIndicator ) {
	        this.addViewIndicator();
	    }

	    // Reverse dragging direction
	    if ( this.options.reverseDragging ) {
	        this.reverseDraggingDirection();
	    }

	    // Register event if reticle is enabled, otherwise defaults to mouse
	    if ( this.options.enableReticle ) {
	        this.enableReticleControl();
	    } else {
	        this.registerMouseAndTouchEvents();
	    }

	    // Output infospot position to an overlay container if specified
	    if ( this.options.output === 'overlay' ) {
	        this.addOutputElement();
	    }

	    // Register dom event listeners
	    this.registerEventListeners();

	    // Animate
	    this.animate.call( this );

	}
	Viewer.prototype = Object.assign( Object.create( THREE.EventDispatcher.prototype ), {

	    constructor: Viewer,

	    /**
	     * Add an object to the scene
	     * Automatically hookup with panolens-viewer-handler listener
	     * to communicate with viewer method
	     * @param {THREE.Object3D} object - The object to be added
	     * @memberOf Viewer
	     * @instance
	     */
	    add: function ( object ) {

	        if ( arguments.length > 1 ) {

	            for ( let i = 0; i < arguments.length; i ++ ) {

	                this.add( arguments[ i ] );

	            }

	            return this;

	        }

	        this.scene.add( object );

	        // All object added to scene has 'panolens-viewer-handler' event to handle viewer communication
	        if ( object.addEventListener ) {

	            object.addEventListener( 'panolens-viewer-handler', this.eventHandler.bind( this ) );

	        }

	        // All object added to scene being passed with container
	        if ( object instanceof Panorama && object.dispatchEvent ) {

	            object.dispatchEvent( { type: 'panolens-container', container: this.container } );

	        }

	        if ( object instanceof CameraPanorama ) {

	            object.dispatchEvent( { type: 'panolens-scene', scene: this.scene } );

	        }

	        // Hookup default panorama event listeners
	        if ( object.type === 'panorama' ) {

	            this.addPanoramaEventListener( object );

	            if ( !this.panorama ) {

	               // this.setPanorama( object );

	            }

	        }

	    },

	    /**
	     * Remove an object from the scene
	     * @param  {THREE.Object3D} object - Object to be removed
	     * @memberOf Viewer
	     * @instance
	     */
	    remove: function ( object ) {

	        if ( object.removeEventListener ) {

	            object.removeEventListener( 'panolens-viewer-handler', this.eventHandler.bind( this ) );

	        }

	        this.scene.remove( object );

	    },

	    /**
	     * Add default control bar
	     * @param {array} array - The control buttons array
	     * @memberOf Viewer
	     * @instance
	     */
	    addDefaultControlBar: function ( array ) {

	        if ( this.widget ) {

	            console.warn( 'Default control bar exists' );
	            return;

	        }

	        const widget = new Widget( this );
	        widget.addEventListener( 'panolens-viewer-handler', this.eventHandler.bind( this ) );
	        widget.addControlBar();
	        array.forEach( buttonName => {

	            widget.addControlButton( buttonName );

	        } );

	        this.widget = widget;

	    },

	    /**
	     * Set a panorama to be the current one
	     * @param {Panorama} pano - Panorama to be set
	     * @memberOf Viewer
	     * @instance
	     */
	    setPanorama: function ( pano ) {
			
			try{
				const leavingPanorama = this.panorama;
				var vwr = this;
				//THREE.Cache.clear();
				if(leavingPanorama != null)
				{
					//THREE.Cache.remove( leavingPanorama.src );
					//leavingPanorama.dispose();
				} 
				//$(".panolens-infospot").css("display","none");
				
				if ( pano.type === 'panorama' && leavingPanorama !== pano ) {

					// Clear exisiting infospot
					this.hideInfospot();
					const afterEnterComplete = function () {
						EnableDisableHomeScreen();
						if ( leavingPanorama ) { 
							leavingPanorama.onLeave(); 
						}
						pano.removeEventListener( 'enter-fade-start', afterEnterComplete );
					};
					pano.addEventListener( 'enter-fade-start', afterEnterComplete );
					// Assign and enter panorama
					(this.panorama = pano).onEnter();
					
				}
				else
				{
					EnableDisableHomeScreen();
				}
			}
			catch(e)
			{
				console.info("-----------errrr found-------setPanorama-------");
				console.info(e);
			}
	        

	    },

	    /**
	     * Event handler to execute commands from child objects
	     * @param {object} event - The dispatched event with method as function name and data as an argument
	     * @memberOf Viewer
	     * @instance
	     */
	    eventHandler: function ( event ) {

	        if ( event.method && this[ event.method ] ) {

	            this[ event.method ]( event.data );

	        }

	    },

	    /**
	     * Dispatch event to all descendants
	     * @param  {object} event - Event to be passed along
	     * @memberOf Viewer
	     * @instance
	     */
	    dispatchEventToChildren: function ( event ) {

	        this.scene.traverse( function ( object ) {

	            if ( object.dispatchEvent ) {

	                object.dispatchEvent( event );

	            }

	        });

	    },

	    /**
	     * Set widget content
	     * @method activateWidgetItem
	     * @param  {integer} controlIndex - Control index
	     * @param  {integer} mode - Modes for effects
	     * @memberOf Viewer
	     * @instance
	     */
	    activateWidgetItem: function ( controlIndex, mode ) {

	        const mainMenu = this.widget.mainMenu;
	        const ControlMenuItem = mainMenu.children[ 0 ];
	        const ModeMenuItem = mainMenu.children[ 1 ];

	        let item;

	        if ( controlIndex !== undefined ) {

	            switch ( controlIndex ) {

	            case 0:

	                item = ControlMenuItem.subMenu.children[ 1 ];

	                break;

	            case 1:

	                item = ControlMenuItem.subMenu.children[ 2 ];

	                break;
						
	            default:

	                item = ControlMenuItem.subMenu.children[ 1 ];

	                break;	

	            }

	            ControlMenuItem.subMenu.setActiveItem( item );
	            ControlMenuItem.setSelectionTitle( item.textContent );

	        }

	        if ( mode !== undefined ) {

	            switch( mode ) {

	            case MODES.CARDBOARD:
	                item = ModeMenuItem.subMenu.children[ 2 ];

	                break;

	            case MODES.STEREO:

	                item = ModeMenuItem.subMenu.children[ 3 ];
						
	                break;

	            default:

	                item = ModeMenuItem.subMenu.children[ 1 ];

	                break;
	            }

	            ModeMenuItem.subMenu.setActiveItem( item );
	            ModeMenuItem.setSelectionTitle( item.textContent );

	        }

	    },

	    /**
	     * Enable rendering effect
	     * @param  {MODES} mode - Modes for effects
	     * @memberOf Viewer
	     * @instance
	     */
	    enableEffect: function ( mode ) {
			if(mobileOperatingSystem != "iOS")
			{
				isFullscreen = false;
				this.widget.EnableDisableFullScreen();	
			}
			
			if(mobileOperatingSystem != "unknown")
			{
				this.enableControl(1);
			} 
			
	        if ( this.mode === mode ) { return; }
	        if ( mode === MODES.NORMAL ) { this.disableEffect(); return; }
	        else { this.mode = mode; }

	        const fov = this.camera.fov;

	        switch( mode ) {

	        case MODES.CARDBOARD:
	            this.effect = this.CardboardEffect;
	            this.enableReticleControl();

	            break;

	        case MODES.STEREO:

	            this.effect = this.StereoEffect;
	            this.enableReticleControl();
					
	            break;

	        default:

	            this.effect = null;
	            this.disableReticleControl();

	            break;

	        }

	        this.activateWidgetItem( undefined, this.mode );

	        /**
	         * Dual eye effect event
	         * @type {object}
	         * @event Infospot#panolens-dual-eye-effect
	         * @property {MODES} mode - Current display mode
	         */
	        this.dispatchEventToChildren( { type: 'panolens-dual-eye-effect', mode: this.mode } );

	        // Force effect stereo camera to update by refreshing fov
	        this.camera.fov = fov + 10e-3;
	        this.effect.setSize( this.container.clientWidth, this.container.clientHeight );
	        this.render();
	        this.camera.fov = fov;
	        /**
	         * Dispatch mode change event
	         * @type {object}
	         * @event Viewer#mode-change
	         * @property {MODES} mode - Current display mode
	         */
	        this.dispatchEvent( { type: 'mode-change', mode: this.mode } );
			
	    },

	    /**
	     * Disable additional rendering effect
	     * @memberOf Viewer
	     * @instance
	     */
	    disableEffect: function () {
			//this.enableControl(0);
			
	        if ( this.mode === MODES.NORMAL ) { return; }

	        this.mode = MODES.NORMAL;
	        this.disableReticleControl();

	        this.activateWidgetItem( undefined, this.mode );

	        /**
	         * Dual eye effect event
	         * @type {object}
	         * @event Infospot#panolens-dual-eye-effect
	         * @property {MODES} mode - Current display mode
	         */
	        this.dispatchEventToChildren( { type: 'panolens-dual-eye-effect', mode: this.mode } );

	        this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );
	        this.render();

	        /**
	         * Dispatch mode change event
	         * @type {object}
	         * @event Viewer#mode-change
	         * @property {MODES} mode - Current display mode
	         */
	        this.dispatchEvent( { type: 'mode-change', mode: this.mode } );
			//isFullscreen = true;
			//this.widget.EnableDisableFullScreen();
	    },

	    /**
	     * Enable reticle control
	     * @memberOf Viewer
	     * @instance
	     */
	    enableReticleControl: function () {
	        if ( this.reticle.visible ) { return; }

	        this.tempEnableReticle = true;

	        // Register reticle event and unregister mouse event
	        this.unregisterMouseAndTouchEvents();
	        this.reticle.show();
	        this.registerReticleEvent();
	        this.updateReticleEvent();

	    },

	    /**
	     * Disable reticle control
	     * @memberOf Viewer
	     * @instance
	     */
	    disableReticleControl: function () {

	        this.tempEnableReticle = false;

	        // Register mouse event and unregister reticle event
	        if ( !this.options.enableReticle ) {

	            this.reticle.hide();
	            this.unregisterReticleEvent();
	            this.registerMouseAndTouchEvents();

	        } else {

	            this.updateReticleEvent();

	        }

	    },

	    /**
	     * Enable auto rotation
	     * @memberOf Viewer
	     * @instance
	     */
	    enableAutoRate: function () {

	        this.options.autoRotate = true;
	        this.OrbitControls.autoRotate = true;

	    },

	    /**
	     * Disable auto rotation
	     * @memberOf Viewer
	     * @instance
	     */
	    disableAutoRate: function () {

	        clearTimeout( this.autoRotateRequestId );
	        this.options.autoRotate = false;
	        this.OrbitControls.autoRotate = false;

	    },

	    /**
	     * Toggle video play or stop
	     * @param {boolean} pause
	     * @memberOf Viewer
	     * @instance
	     * @fires Viewer#video-toggle
	     */
	    toggleVideoPlay: function ( pause ) {

	        if ( this.panorama instanceof VideoPanorama ) {

	            /**
	             * Toggle video event
	             * @type {object}
	             * @event Viewer#video-toggle
	             */
	            this.panorama.dispatchEvent( { type: 'video-toggle', pause: pause } );

	        }

	    },

	    /**
	     * Set currentTime in a video
	     * @param {number} percentage - Percentage of a video. Range from 0.0 to 1.0
	     * @memberOf Viewer
	     * @instance
	     * @fires Viewer#video-time
	     */
	    setVideoCurrentTime: function ( percentage ) {

	        if ( this.panorama instanceof VideoPanorama ) {

	            /**
	             * Setting video time event
	             * @type {object}
	             * @event Viewer#video-time
	             * @property {number} percentage - Percentage of a video. Range from 0.0 to 1.0
	             */
	            this.panorama.dispatchEvent( { type: 'video-time', percentage: percentage } );

	        }

	    },

	    /**
	     * This will be called when video updates if an widget is present
	     * @param {number} percentage - Percentage of a video. Range from 0.0 to 1.0
	     * @memberOf Viewer
	     * @instance
	     * @fires Viewer#video-update
	     */
	    onVideoUpdate: function ( percentage ) {

	        const { widget } = this;

	        /**
	         * Video update event
	         * @type {object}
	         * @event Viewer#video-update
	         * @property {number} percentage - Percentage of a video. Range from 0.0 to 1.0
	         */
	        if( widget ) { widget.dispatchEvent( { type: 'video-update', percentage: percentage } ); }

	    },

	    /**
	     * Add update callback to be called every animation frame
	     * @param {function} callback
	     * @memberOf Viewer
	     * @instance
	     */
	    addUpdateCallback: function ( fn ) {

	        if ( fn ) {

	            this.updateCallbacks.push( fn );

	        }

	    },

	    /**
	     * Remove update callback
	     * @param  {function} fn - The function to be removed
	     * @memberOf Viewer
	     * @instance
	     */
	    removeUpdateCallback: function ( fn ) {

	        const index = this.updateCallbacks.indexOf( fn );

	        if ( fn && index >= 0 ) {

	            this.updateCallbacks.splice( index, 1 );

	        }

	    },

	    /**
	     * Show video widget
	     * @memberOf Viewer
	     * @instance
	     */
	    showVideoWidget: function () {

	        const { widget } = this;

	        /**
	         * Show video widget event
	         * @type {object}
	         * @event Viewer#video-control-show
	         */
	        if( widget ) { widget.dispatchEvent( { type: 'video-control-show' } ); }

	    },

	    /**
	     * Hide video widget
	     * @memberOf Viewer
	     * @instance
	     */
	    hideVideoWidget: function () {

	        const { widget } = this;

	        /**
	         * Hide video widget
	         * @type {object}
	         * @event Viewer#video-control-hide
	         */
	        if( widget ) { widget.dispatchEvent( { type: 'video-control-hide' } ); }

	    },

	    /**
	     * Update video play button
	     * @param {boolean} paused 
	     * @memberOf Viewer
	     * @instance
	     */
	    updateVideoPlayButton: function ( paused ) {

	        const { widget } = this;

	        if ( widget && widget.videoElement && widget.videoElement.controlButton ) {

	            widget.videoElement.controlButton.update( paused );

	        }

	    },

	    /**
	     * Add default panorama event listeners
	     * @param {Panorama} pano - The panorama to be added with event listener
	     * @memberOf Viewer
	     * @instance
	     */
	    addPanoramaEventListener: function ( pano ) {

	        // Set camera control on every panorama
	        pano.addEventListener( 'enter-fade-start', this.setCameraControl.bind( this ) );

	        // Show and hide widget event only when it's VideoPanorama
	        if ( pano instanceof VideoPanorama ) {

	            pano.addEventListener( 'enter-fade-start', this.showVideoWidget.bind( this ) );
	            pano.addEventListener( 'leave', function () {

	                if ( !(this.panorama instanceof VideoPanorama) ) {

	                    this.hideVideoWidget.call( this );

	                }
					
	            }.bind( this ) );

	        }

	    },

	    /**
	     * Set camera control
	     * @memberOf Viewer
	     * @instance
	     */
	    setCameraControl: function () {

	        this.OrbitControls.target.copy( this.panorama.position );

	    },

	    /**
	     * Get current camera control
	     * @return {object} - Current navigation control
	     * @memberOf Viewer
	     * @instance
	     * @returns {THREE.OrbitControls|THREE.DeviceOrientationControls}
	     */
	    getControl: function () {

	        return this.control;

	    },

	    /**
	     * Get scene
	     * @memberOf Viewer
	     * @instance
	     * @return {THREE.Scene} - Current scene which the viewer is built on
	     */
	    getScene: function () {

	        return this.scene;

	    },

	    /**
	     * Get camera
	     * @memberOf Viewer
	     * @instance
	     * @return {THREE.Camera} - The scene camera
	     */
	    getCamera: function () {

	        return this.camera;

	    },

	    /**
	     * Get renderer
	     * @memberOf Viewer
	     * @instance
	     * @return {THREE.WebGLRenderer} - The renderer using webgl
	     */
	    getRenderer: function () {

	        return this.renderer;

	    },

	    /**
	     * Get container
	     * @memberOf Viewer
	     * @instance
	     * @return {HTMLElement} - The container holds rendererd canvas
	     */
	    getContainer: function () {

	        return this.container;

	    },

	    /**
	     * Get control id
	     * @memberOf Viewer
	     * @instance
	     * @return {string} - Control id. 'orbit' or 'device-orientation'
	     */
	    getControlId: function () {

	        return this.control.id;

	    },

	    /**
	     * Get next navigation control id
	     * @memberOf Viewer
	     * @instance
	     * @return {string} - Next control id
	     */
	    getNextControlId: function () {

	        return this.controls[ this.getNextControlIndex() ].id;

	    },

	    /**
	     * Get next navigation control index
	     * @memberOf Viewer
	     * @instance
	     * @return {number} - Next control index
	     */
	    getNextControlIndex: function () {

	        const controls = this.controls;
	        const control = this.control;
	        const nextIndex = controls.indexOf( control ) + 1;

	        return ( nextIndex >= controls.length ) ? 0 : nextIndex;

	    },

	    /**
	     * Set field of view of camera
	     * @param {number} fov
	     * @memberOf Viewer
	     * @instance
	     */
	    setCameraFov: function ( fov ) {

	        this.camera.fov = fov;
	        this.camera.updateProjectionMatrix();

	    },

	    /**
	     * Enable control by index
	     * @param  {CONTROLS} index - Index of camera control
	     * @memberOf Viewer
	     * @instance
	     */
	    enableControl: function ( index ) {
	        index = ( index >= 0 && index < this.controls.length ) ? index : 0;

	        this.control.enabled = false;

	        this.control = this.controls[ index ];

	        this.control.enabled = true;

	        switch ( index ) {

	        case CONTROLS.ORBIT:
				console.info("---------ORBIT---------------");
	            this.camera.position.copy( this.panorama.position );
	            this.camera.position.z += 1;

	            break;

	        case CONTROLS.DEVICEORIENTATION:
				console.info("---------DEVICEORIENTATION---------------");
				requestOrientation();
	            this.camera.position.copy( this.panorama.position );

	            break;

	        default:

	            break;
	        }

	        this.control.update();

	        this.activateWidgetItem( index, undefined );

	    },

	    /**
	     * Disable current control
	     * @memberOf Viewer
	     * @instance
	     */
	    disableControl: function () {

	        this.control.enabled = false;

	    },

	    /**
	     * Toggle next control
	     * @memberOf Viewer
	     * @instance
	     */
	    toggleNextControl: function () {

	        this.enableControl( this.getNextControlIndex() );

	    },

	    /**
	     * Screen Space Projection
	     * @memberOf Viewer
	     * @instance
	     */
	    getScreenVector: function ( worldVector ) {

	        const vector = worldVector.clone();
	        const widthHalf = ( this.container.clientWidth ) / 2;
	        const heightHalf = this.container.clientHeight / 2;

	        vector.project( this.camera );

	        vector.x = ( vector.x * widthHalf ) + widthHalf;
	        vector.y = - ( vector.y * heightHalf ) + heightHalf;
	        vector.z = 0;

	        return vector;

	    },

	    /**
	     * Check Sprite in Viewport
	     * @memberOf Viewer
	     * @instance
	     */
	    checkSpriteInViewport: function ( sprite ) {

	        this.camera.matrixWorldInverse.getInverse( this.camera.matrixWorld );
	        this.cameraViewProjectionMatrix.multiplyMatrices( this.camera.projectionMatrix, this.camera.matrixWorldInverse );
	        this.cameraFrustum.setFromMatrix( this.cameraViewProjectionMatrix );

	        return sprite.visible && this.cameraFrustum.intersectsSprite( sprite );

	    },

	    /**
	     * Reverse dragging direction
	     * @memberOf Viewer
	     * @instance
	     */
	    reverseDraggingDirection: function () {

	        this.OrbitControls.rotateSpeed *= -1;
	        this.OrbitControls.momentumScalingFactor *= -1;

	    },

	    /**
	     * Add reticle 
	     * @memberOf Viewer
	     * @instance
	     */
		 
		// #ffc926
	    addReticle: function () {

	        this.reticle = new Reticle( 0xffffff, true, this.options.dwellTime );
	        this.reticle.hide();
	        this.camera.add( this.reticle );
	        this.sceneReticle.add( this.camera );

	    },

	    /**
	     * Tween control looking center
	     * @param {THREE.Vector3} vector - Vector to be looked at the center
	     * @param {number} [duration=1000] - Duration to tween
	     * @param {function} [easing=TWEEN.Easing.Exponential.Out] - Easing function
	     * @memberOf Viewer
	     * @instance
	     */
	    tweenControlCenter: function ( vector, duration, easing ) {

	        if ( this.control !== this.OrbitControls ) {

	            return;

	        }

	        // Pass in arguments as array
	        if ( vector instanceof Array ) {

	            duration = vector[ 1 ];
	            easing = vector[ 2 ];
	            vector = vector[ 0 ];

	        }

	        duration = duration !== undefined ? duration : 1000;
	        easing = easing || Tween.Easing.Exponential.Out;

	        let scope, ha, va, chv, cvv, hv, vv, vptc, ov, nv;

	        scope = this;

	        chv = this.camera.getWorldDirection( new THREE.Vector3() );
	        cvv = chv.clone();

	        vptc = this.panorama.getWorldPosition( new THREE.Vector3() ).sub( this.camera.getWorldPosition( new THREE.Vector3() ) );

	        hv = vector.clone();
	        // Scale effect
	        hv.x *= -1;
	        hv.add( vptc ).normalize();
	        vv = hv.clone();

	        chv.y = 0;
	        hv.y = 0;

	        ha = Math.atan2( hv.z, hv.x ) - Math.atan2( chv.z, chv.x );
	        ha = ha > Math.PI ? ha - 2 * Math.PI : ha;
	        ha = ha < -Math.PI ? ha + 2 * Math.PI : ha;
	        va = Math.abs( cvv.angleTo( chv ) + ( cvv.y * vv.y <= 0 ? vv.angleTo( hv ) : -vv.angleTo( hv ) ) );
	        va *= vv.y < cvv.y ? 1 : -1;

	        ov = { left: 0, up: 0 };
	        nv = { left: 0, up: 0 };

	        this.tweenLeftAnimation.stop();
	        this.tweenUpAnimation.stop();

	        this.tweenLeftAnimation = new Tween.Tween( ov )
	            .to( { left: ha }, duration )
	            .easing( easing )
	            .onUpdate(function(ov){
	                scope.control.rotateLeft( ov.left - nv.left );
	                nv.left = ov.left;
	            })
	            .start();

	        this.tweenUpAnimation = new Tween.Tween( ov )
	            .to( { up: va }, duration )
	            .easing( easing )
	            .onUpdate(function(ov){
	                scope.control.rotateUp( ov.up - nv.up );
	                nv.up = ov.up;
	            })
	            .start();

	    },

	    /**
	     * Tween control looking center by object
	     * @param {THREE.Object3D} object - Object to be looked at the center
	     * @param {number} [duration=1000] - Duration to tween
	     * @param {function} [easing=TWEEN.Easing.Exponential.Out] - Easing function
	     * @memberOf Viewer
	     * @instance
	     */
	    tweenControlCenterByObject: function ( object, duration, easing ) {

	        let isUnderScalePlaceHolder = false;

	        object.traverseAncestors( function ( ancestor ) {

	            if ( ancestor.scalePlaceHolder ) {

	                isUnderScalePlaceHolder = true;

	            }
	        } );

	        if ( isUnderScalePlaceHolder ) {

	            const invertXVector = new THREE.Vector3( -1, 1, 1 );

	            this.tweenControlCenter( object.getWorldPosition( new THREE.Vector3() ).multiply( invertXVector ), duration, easing );

	        } else {

	            this.tweenControlCenter( object.getWorldPosition( new THREE.Vector3() ), duration, easing );

	        }

	    },

	    /**
	     * This is called when window size is changed
	     * @fires Viewer#window-resize
	     * @param {number} [windowWidth] - Specify if custom element has changed width
	     * @param {number} [windowHeight] - Specify if custom element has changed height
	     * @memberOf Viewer
	     * @instance
	     */
	    onWindowResize: function ( windowWidth, windowHeight ) {

	        let width, height;

	        const expand = this.container.classList.contains( 'panolens-container' ) || this.container.isFullscreen;

	        if ( windowWidth !== undefined && windowHeight !== undefined ) {

	            width = windowWidth;
	            height = windowHeight;
	            this.container._width = windowWidth;
	            this.container._height = windowHeight;

	        } else {

	            const isAndroid = /(android)/i.test(window.navigator.userAgent);

	            const adjustWidth = isAndroid 
	                ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) 
	                : Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

	            const adjustHeight = isAndroid 
	                ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) 
	                : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

	            width = expand ? adjustWidth : this.container.clientWidth;
	            height = expand ? adjustHeight : this.container.clientHeight;

	            this.container._width = width;
	            this.container._height = height;

	        }

	        this.camera.aspect = width / height;
	        this.camera.updateProjectionMatrix();

	        this.renderer.setSize( width, height );

	        // Update reticle
	        if ( this.options.enableReticle || this.tempEnableReticle ) {

	            this.updateReticleEvent();

	        }

	        /**
	         * Window resizing event
	         * @type {object}
	         * @event Viewer#window-resize
	         * @property {number} width  - Width of the window
	         * @property {number} height - Height of the window
	         */
	        this.dispatchEvent( { type: 'window-resize', width: width, height: height });
	        this.scene.traverse( function ( object ) {

	            if ( object.dispatchEvent ) {

	                object.dispatchEvent( { type: 'window-resize', width: width, height: height });

	            }

	        } );

	    },

	    /**
	     * Add output element
	     * @memberOf Viewer
	     * @instance
	     */
	    addOutputElement: function () {

	        const element = document.createElement( 'div' );
	        element.style.position = 'absolute';
	        element.style.right = '10px';
	        element.style.top = '10px';
	        element.style.color = '#fff';
	        this.container.appendChild( element );
	        this.outputDivElement = element;

	    },

	    /**
	     * Output position in developer console by holding down Ctrl button
	     * @memberOf Viewer
	     * @instance
	     */
	    outputPosition: function () {

	        const intersects = this.raycaster.intersectObject( this.panorama, true );
	        if ( intersects.length > 0 ) {

	            const point = intersects[ 0 ].point.clone();
	            const converter = new THREE.Vector3( -1, 1, 1 );
	            const world = this.panorama.getWorldPosition( new THREE.Vector3() );
	            point.sub( world ).multiply( converter );

	            const message = `${point.x.toFixed(2)}, ${point.y.toFixed(2)}, ${point.z.toFixed(2)}`;

	            if ( point.length() === 0 ) { return; }

	            switch ( this.options.output ) {

	            case 'console':
	                console.info( message );
	                break;

	            case 'overlay':
	                this.outputDivElement.textContent = message;
	                break;

	            default:
	                break;

	            }

	        }

	    },

	    /**
	     * On mouse down
	     * @param {MouseEvent} event 
	     * @memberOf Viewer
	     * @instance
	     */
	    onMouseDown: function ( event ) {
	        event.preventDefault();

	        this.userMouse.x = ( event.clientX >= 0 ) ? event.clientX : event.touches[0].clientX;
	        this.userMouse.y = ( event.clientY >= 0 ) ? event.clientY : event.touches[0].clientY;
	        this.userMouse.type = 'mousedown';
	        this.onTap( event );

	    },

	    /**
	     * On mouse move
	     * @param {MouseEvent} event 
	     * @memberOf Viewer
	     * @instance
	     */
	    onMouseMove: function ( event ) {

	        event.preventDefault();
	        this.userMouse.type = 'mousemove';
	        this.onTap( event );

	    },

	    /**
	     * On mouse up
	     * @param {MouseEvent} event 
	     * @memberOf Viewer
	     * @instance
	     */
	    onMouseUp: function ( event ) {

	        let onTarget = false;

	        this.userMouse.type = 'mouseup';

	        const type = ( this.userMouse.x >= event.clientX - this.options.clickTolerance 
					&& this.userMouse.x <= event.clientX + this.options.clickTolerance
					&& this.userMouse.y >= event.clientY - this.options.clickTolerance
					&& this.userMouse.y <= event.clientY + this.options.clickTolerance ) 
					||  ( event.changedTouches 
					&& this.userMouse.x >= event.changedTouches[0].clientX - this.options.clickTolerance
					&& this.userMouse.x <= event.changedTouches[0].clientX + this.options.clickTolerance 
					&& this.userMouse.y >= event.changedTouches[0].clientY - this.options.clickTolerance
					&& this.userMouse.y <= event.changedTouches[0].clientY + this.options.clickTolerance ) 
	            ? 'click' : undefined;

	        // Event should happen on canvas
	        if ( event && event.target && !event.target.classList.contains( 'panolens-canvas' ) ) { return; }

	        event.preventDefault();

	        if ( event.changedTouches && event.changedTouches.length === 1 ) {

	            onTarget = this.onTap( { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY }, type );
			
	        } else {

	            onTarget = this.onTap( event, type );

	        }

	        this.userMouse.type = 'none';

	        if ( onTarget ) { 

	            return; 

	        }

	        if ( type === 'click' ) {

	            const { options: { autoHideInfospot, autoHideControlBar }, panorama, toggleControlBar } = this;

	            if ( autoHideInfospot && panorama ) {

	                panorama.toggleInfospotVisibility();

	            }

	            if ( autoHideControlBar ) {

	                toggleControlBar();

	            }

	        }

	    },

	    /**
	     * On tap eveny frame
	     * @param {MouseEvent} event 
	     * @param {string} type 
	     * @memberOf Viewer
	     * @instance
	     */
	    onTap: function ( event, type ) {

	        const { left, top } = this.container.getBoundingClientRect();
	        const { clientWidth, clientHeight } = this.container;

	        this.raycasterPoint.x = ( ( event.clientX - left ) / clientWidth ) * 2 - 1;
	        this.raycasterPoint.y = - ( ( event.clientY - top ) / clientHeight ) * 2 + 1;

	        this.raycaster.setFromCamera( this.raycasterPoint, this.camera );

	        // Return if no panorama 
	        if ( !this.panorama ) { 

	            return; 

	        }

	        // output infospot information
	        if ( event.type !== 'mousedown' && this.touchSupported || this.OUTPUT_INFOSPOT ) { 

	            this.outputPosition(); 

	        }

	        const intersects = this.raycaster.intersectObjects( this.panorama.children, true );
	        const intersect_entity = this.getConvertedIntersect( intersects );
	        const intersect = ( intersects.length > 0 ) ? intersects[0].object : undefined;

	        if ( this.userMouse.type === 'mouseup'  ) {

	            if ( intersect_entity && this.pressEntityObject === intersect_entity && this.pressEntityObject.dispatchEvent ) {

	                this.pressEntityObject.dispatchEvent( { type: 'pressstop-entity', mouseEvent: event } );

	            }

	            this.pressEntityObject = undefined;

	        }

	        if ( this.userMouse.type === 'mouseup'  ) {

	            if ( intersect && this.pressObject === intersect && this.pressObject.dispatchEvent ) {

	                this.pressObject.dispatchEvent( { type: 'pressstop', mouseEvent: event } );

	            }

	            this.pressObject = undefined;

	        }

	        if ( type === 'click' ) {

	            this.panorama.dispatchEvent( { type: 'click', intersects: intersects, mouseEvent: event } );

	            if ( intersect_entity && intersect_entity.dispatchEvent ) {

	                intersect_entity.dispatchEvent( { type: 'click-entity', mouseEvent: event } );

	            }

	            if ( intersect && intersect.dispatchEvent ) {

	                intersect.dispatchEvent( { type: 'click', mouseEvent: event } );

	            }

	        } else {

	            this.panorama.dispatchEvent( { type: 'hover', intersects: intersects, mouseEvent: event } );

	            if ( ( this.hoverObject && intersects.length > 0 && this.hoverObject !== intersect_entity )
					|| ( this.hoverObject && intersects.length === 0 ) ){

	                if ( this.hoverObject.dispatchEvent ) {

	                    this.hoverObject.dispatchEvent( { type: 'hoverleave', mouseEvent: event } );

	                    this.reticle.end();

	                }

	                this.hoverObject = undefined;

	            }

	            if ( intersect_entity && intersects.length > 0 ) {

	                if ( this.hoverObject !== intersect_entity ) {

	                    this.hoverObject = intersect_entity;

	                    if ( this.hoverObject.dispatchEvent ) {

	                        this.hoverObject.dispatchEvent( { type: 'hoverenter', mouseEvent: event } );

	                        // Start reticle timer
	                        if ( this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle ) {
	                            this.reticle.start( this.onTap.bind( this, event, 'click' ) );
	                        }

	                    }

	                }

	                if ( this.userMouse.type === 'mousedown' && this.pressEntityObject != intersect_entity ) {

	                    this.pressEntityObject = intersect_entity;

	                    if ( this.pressEntityObject.dispatchEvent ) {

	                        this.pressEntityObject.dispatchEvent( { type: 'pressstart-entity', mouseEvent: event } );

	                    }

	                }

	                if ( this.userMouse.type === 'mousedown' && this.pressObject != intersect ) {

	                    this.pressObject = intersect;

	                    if ( this.pressObject.dispatchEvent ) {

	                        this.pressObject.dispatchEvent( { type: 'pressstart', mouseEvent: event } );

	                    }

	                }

	                if ( this.userMouse.type === 'mousemove' || this.options.enableReticle ) {

	                    if ( intersect && intersect.dispatchEvent ) {

	                        intersect.dispatchEvent( { type: 'hover', mouseEvent: event } );

	                    }

	                    if ( this.pressEntityObject && this.pressEntityObject.dispatchEvent ) {

	                        this.pressEntityObject.dispatchEvent( { type: 'pressmove-entity', mouseEvent: event } );

	                    }

	                    if ( this.pressObject && this.pressObject.dispatchEvent ) {

	                        this.pressObject.dispatchEvent( { type: 'pressmove', mouseEvent: event } );

	                    }

	                }

	            }

	            if ( !intersect_entity && this.pressEntityObject && this.pressEntityObject.dispatchEvent ) {

	                this.pressEntityObject.dispatchEvent( { type: 'pressstop-entity', mouseEvent: event } );

	                this.pressEntityObject = undefined;

	            }

	            if ( !intersect && this.pressObject && this.pressObject.dispatchEvent ) {

	                this.pressObject.dispatchEvent( { type: 'pressstop', mouseEvent: event } );

	                this.pressObject = undefined;

	            }

	        }

	        // Infospot handler
	        if ( intersect && intersect instanceof Infospot ) {

	            this.infospot = intersect;
				
	            if ( type === 'click' ) {

	                return true;

	            }
				

	        } else if ( this.infospot ) {

	            this.hideInfospot();

	        }

	        // Auto rotate
	        if ( this.options.autoRotate && this.userMouse.type !== 'mousemove' ) {

	            // Auto-rotate idle timer
	            clearTimeout( this.autoRotateRequestId );

	            if ( this.control === this.OrbitControls ) {

	                this.OrbitControls.autoRotate = false;
	                this.autoRotateRequestId = window.setTimeout( this.enableAutoRate.bind( this ), this.options.autoRotateActivationDuration );

	            }

	        }		

	    },

	    /**
	     * Get converted intersect
	     * @param {array} intersects 
	     * @memberOf Viewer
	     * @instance
	     */
	    getConvertedIntersect: function ( intersects ) {

	        let intersect;

	        for ( let i = 0; i < intersects.length; i++ ) {

	            if ( intersects[i].distance >= 0 && intersects[i].object && !intersects[i].object.passThrough ) {

	                if ( intersects[i].object.entity && intersects[i].object.entity.passThrough ) {
	                    continue;
	                } else if ( intersects[i].object.entity && !intersects[i].object.entity.passThrough ) {
	                    intersect = intersects[i].object.entity;
	                    break;
	                } else {
	                    intersect = intersects[i].object;
	                    break;
	                }

	            }

	        }

	        return intersect;

	    },

	    /**
	     * Hide infospot
	     * @memberOf Viewer
	     * @instance
	     */
	    hideInfospot: function () {

	        if ( this.infospot ) {

	            this.infospot.onHoverEnd();

	            this.infospot = undefined;

	        }

	    },

	    /**
	     * Toggle control bar
	     * @memberOf Viewer
	     * @instance
	     * @fires Viewer#control-bar-toggle
	     */
	    toggleControlBar: function () {

	        const { widget } = this;

	        /**
	         * Toggle control bar event
	         * @type {object}
	         * @event Viewer#control-bar-toggle
	         */
	        if ( widget ) {

	            widget.dispatchEvent( { type: 'control-bar-toggle' } );

	        }

	    },

	    /**
	     * On key down
	     * @param {KeyboardEvent} event 
	     * @memberOf Viewer
	     * @instance
	     */
	    onKeyDown: function ( event ) {

	        if ( this.options.output && this.options.output !== 'none' && event.key === 'Control' ) {

	            this.OUTPUT_INFOSPOT = true;

	        }

	    },

	    /**
	     * On key up
	     * @param {KeyboardEvent} event 
	     * @memberOf Viewer
	     * @instance
	     */
	    onKeyUp: function () {

	        this.OUTPUT_INFOSPOT = false;

	    },

	    /**
	     * Update control and callbacks
	     * @memberOf Viewer
	     * @instance
	     */
	    update: function () {

	        Tween.update();

	        this.updateCallbacks.forEach( function( callback ){ callback(); } );

	        this.control.update();

	        this.scene.traverse( function( child ){
	            if ( child instanceof Infospot 
					&& child.element 
					&& ( this.hoverObject === child 
						|| child.element.style.display !== 'none' 
						|| (child.element.left && child.element.left.style.display !== 'none')
						|| (child.element.right && child.element.right.style.display !== 'none') ) ) {
	                if ( this.checkSpriteInViewport( child ) ) {
	                    const { x, y } = this.getScreenVector( child.getWorldPosition( new THREE.Vector3() ) );
	                    child.translateElement( x, y );
	                } else {
	                    child.onDismiss();
	                }
					
	            }
	        }.bind( this ) );

	    },

	    /**
	     * Rendering function to be called on every animation frame
	     * Render reticle last
	     * @memberOf Viewer
	     * @instance
	     */
	    render: function () {

	        if ( this.mode === MODES.CARDBOARD || this.mode === MODES.STEREO ) {
	            this.renderer.clear();
	            this.effect.render( this.scene, this.camera );
	            this.effect.render( this.sceneReticle, this.camera );
				

	        } else {

	            this.renderer.clear();
	            this.renderer.render( this.scene, this.camera );
	            this.renderer.clearDepth();
	            this.renderer.render( this.sceneReticle, this.camera );

	        }

	    },

	    /**
	     * Animate
	     * @memberOf Viewer
	     * @instance
	     */
	    animate: function () {

	        this.requestAnimationId = window.requestAnimationFrame( this.animate.bind( this ) );

	        this.onChange();

	    },

	    /**
	     * On change
	     * @memberOf Viewer
	     * @instance
	     */
	    onChange: function () {

	        this.update();
	        this.render();

	    },

	    /**
	     * Register mouse and touch event on container
	     * @memberOf Viewer
	     * @instance
	     */
	    registerMouseAndTouchEvents: function () {

	        const options = { passive: false };

	        this.container.addEventListener( 'mousedown' , 	this.HANDLER_MOUSE_DOWN, options );
	        this.container.addEventListener( 'mousemove' , 	this.HANDLER_MOUSE_MOVE, options );
	        this.container.addEventListener( 'mouseup'	 , 	this.HANDLER_MOUSE_UP  , options );
	        this.container.addEventListener( 'touchstart', 	this.HANDLER_MOUSE_DOWN, options );
	        this.container.addEventListener( 'touchend'  , 	this.HANDLER_MOUSE_UP  , options );

	    },

	    /**
	     * Unregister mouse and touch event on container
	     * @memberOf Viewer
	     * @instance
	     */
	    unregisterMouseAndTouchEvents: function () {

	        this.container.removeEventListener( 'mousedown' ,  this.HANDLER_MOUSE_DOWN, false );
	        this.container.removeEventListener( 'mousemove' ,  this.HANDLER_MOUSE_MOVE, false );
	        this.container.removeEventListener( 'mouseup'	,  this.HANDLER_MOUSE_UP  , false );
	        this.container.removeEventListener( 'touchstart',  this.HANDLER_MOUSE_DOWN, false );
	        this.container.removeEventListener( 'touchend'  ,  this.HANDLER_MOUSE_UP  , false );

	    },

	    /**
	     * Register reticle event
	     * @memberOf Viewer
	     * @instance
	     */
	    registerReticleEvent: function () {

	        this.addUpdateCallback( this.HANDLER_TAP );

	    },

	    /**
	     * Unregister reticle event
	     * @memberOf Viewer
	     * @instance
	     */
	    unregisterReticleEvent: function () {

	        this.removeUpdateCallback( this.HANDLER_TAP );

	    },

	    /**
	     * Update reticle event
	     * @memberOf Viewer
	     * @instance
	     */
	    updateReticleEvent: function () {

	        const clientX = this.container.clientWidth / 2 + this.container.offsetLeft;
	        const clientY = this.container.clientHeight / 2;

	        this.removeUpdateCallback( this.HANDLER_TAP );
	        this.HANDLER_TAP = this.onTap.bind( this, { clientX, clientY } );
	        this.addUpdateCallback( this.HANDLER_TAP );

	    },

	    /**
	     * Register container and window listeners
	     * @memberOf Viewer
	     * @instance
	     */
	    registerEventListeners: function () {

	        // Resize Event
	        window.addEventListener( 'resize' , this.HANDLER_WINDOW_RESIZE, true );

	        // Keyboard Event
	        window.addEventListener( 'keydown', this.HANDLER_KEY_DOWN, true );
	        window.addEventListener( 'keyup'  , this.HANDLER_KEY_UP	 , true );

	    },

	    /**
	     * Unregister container and window listeners
	     * @memberOf Viewer
	     * @instance
	     */
	    unregisterEventListeners: function () {

	        // Resize Event
	        window.removeEventListener( 'resize' , this.HANDLER_WINDOW_RESIZE, true );

	        // Keyboard Event
	        window.removeEventListener( 'keydown', this.HANDLER_KEY_DOWN, true );
	        window.removeEventListener( 'keyup'  , this.HANDLER_KEY_UP  , true );

	    },

	    /**
	     * Dispose all scene objects and clear cache
	     * @memberOf Viewer
	     * @instance
	     */
	    dispose: function () {

	        this.tweenLeftAnimation.stop();
	        this.tweenUpAnimation.stop();

	        // Unregister dom event listeners
	        this.unregisterEventListeners();

	        // recursive disposal on 3d objects
	        function recursiveDispose ( object ) {

	            for ( let i = object.children.length - 1; i >= 0; i-- ) {

	                recursiveDispose( object.children[i] );
	                object.remove( object.children[i] );

	            }

	            if ( object instanceof Panorama || object instanceof Infospot ) {

	                object.dispose();
	                object = null;

	            } else if ( object.dispatchEvent ){

	                object.dispatchEvent( 'dispose' );

	            }

	        }

	        recursiveDispose( this.scene );

	        // dispose widget
	        if ( this.widget ) {

	            this.widget.dispose();
	            this.widget = null;

	        }

	        // clear cache
	        if ( THREE.Cache && THREE.Cache.enabled ) {

	            THREE.Cache.clear();

	        }

	    },

	    /**
	     * Destroy viewer by disposing and stopping requestAnimationFrame
	     * @memberOf Viewer
	     * @instance
	     */
	    destroy: function () {

	        this.dispose();
	        this.render();
	        window.cancelAnimationFrame( this.requestAnimationId );		

	    },

	    /**
	     * On panorama dispose
	     * @memberOf Viewer
	     * @instance
	     */
	    onPanoramaDispose: function ( panorama ) {

	        if ( panorama instanceof VideoPanorama ) {

	            this.hideVideoWidget();

	        }

	        if ( panorama === this.panorama ) {

	            this.panorama = null;

	        }

	    },

	    /**
	     * Load ajax call
	     * @param {string} url - URL to be requested
	     * @param {function} [callback] - Callback after request completes
	     * @memberOf Viewer
	     * @instance
	     */
	    loadAsyncRequest: function ( url, callback = () => {} ) {

	        const request = new window.XMLHttpRequest();
	        request.onloadend = function ( event ) {
	            callback( event );
	        };
	        request.open( 'GET', url, true );
	        request.send( null );

	    },

	    /**
	     * View indicator in upper left
	     * @memberOf Viewer
	     * @instance
	     */
	    addViewIndicator: function () {

	        const scope = this;

	        function loadViewIndicator ( asyncEvent ) {

	            if ( asyncEvent.loaded === 0 ) return;

	            const viewIndicatorDiv = asyncEvent.target.responseXML.documentElement;
	            viewIndicatorDiv.style.width = scope.viewIndicatorSize + 'px';
	            viewIndicatorDiv.style.height = scope.viewIndicatorSize + 'px';
	            viewIndicatorDiv.style.position = 'absolute';
	            viewIndicatorDiv.style.top = '10px';
	            viewIndicatorDiv.style.left = '10px';
	            viewIndicatorDiv.style.opacity = '0.5';
	            viewIndicatorDiv.style.cursor = 'pointer';
	            viewIndicatorDiv.id = 'panolens-view-indicator-container';

	            scope.container.appendChild( viewIndicatorDiv );

	            const indicator = viewIndicatorDiv.querySelector( '#indicator' );
	            const setIndicatorD = function () {

	                scope.radius = scope.viewIndicatorSize * 0.225;
	                scope.currentPanoAngle = scope.camera.rotation.y - THREE.Math.degToRad( 90 );
	                scope.fovAngle = THREE.Math.degToRad( scope.camera.fov ) ;
	                scope.leftAngle = -scope.currentPanoAngle - scope.fovAngle / 2;
	                scope.rightAngle = -scope.currentPanoAngle + scope.fovAngle / 2;
	                scope.leftX = scope.radius * Math.cos( scope.leftAngle );
	                scope.leftY = scope.radius * Math.sin( scope.leftAngle );
	                scope.rightX = scope.radius * Math.cos( scope.rightAngle );
	                scope.rightY = scope.radius * Math.sin( scope.rightAngle );
	                scope.indicatorD = 'M ' + scope.leftX + ' ' + scope.leftY + ' A ' + scope.radius + ' ' + scope.radius + ' 0 0 1 ' + scope.rightX + ' ' + scope.rightY;

	                if ( scope.leftX && scope.leftY && scope.rightX && scope.rightY && scope.radius ) {

	                    indicator.setAttribute( 'd', scope.indicatorD );

	                }

	            };

	            scope.addUpdateCallback( setIndicatorD );

	            const indicatorOnMouseEnter = function () {

	                this.style.opacity = '1';

	            };

	            const indicatorOnMouseLeave = function () {

	                this.style.opacity = '0.5';

	            };

	            viewIndicatorDiv.addEventListener( 'mouseenter', indicatorOnMouseEnter );
	            viewIndicatorDiv.addEventListener( 'mouseleave', indicatorOnMouseLeave );
	        }

	        this.loadAsyncRequest( DataImage.ViewIndicator, loadViewIndicator );

	    },

	    /**
	     * Append custom control item to existing control bar
	     * @param {object} [option={}] - Style object to overwirte default element style. It takes 'style', 'onTap' and 'group' properties.
	     * @memberOf Viewer
	     * @instance
	     */
	    appendControlItem: function ( option ) {

	        const item = this.widget.createCustomItem( option );		

	        if ( option.group === 'video' ) {

	            this.widget.videoElement.appendChild( item );

	        } else {

	            this.widget.barElement.appendChild( item );

	        }

	        return item;

	    },

	    /**
	     * Clear all cached files
	     * @memberOf Viewer
	     * @instance
	     */
	    clearAllCache: function () {

	        THREE.Cache.clear();

	    }

	} );

	if ( THREE.REVISION != THREE_REVISION ) {

	    console.warn( `three.js version is not matched. Please consider use the target revision ${THREE_REVISION}` );

	}

	/**
	 * Panolens.js
	 * @author pchen66
	 * @namespace PANOLENS
	 */
	window.TWEEN = Tween;

	exports.BasicPanorama = BasicPanorama;
	exports.CONTROLS = CONTROLS;
	exports.CameraPanorama = CameraPanorama;
	exports.CubePanorama = CubePanorama;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.DataImage = DataImage;
	exports.EmptyPanorama = EmptyPanorama;
	exports.GoogleStreetviewPanorama = GoogleStreetviewPanorama;
	exports.ImageLittlePlanet = ImageLittlePlanet;
	exports.ImageLoader = ImageLoader;
	exports.ImagePanorama = ImagePanorama;
	exports.Infospot = Infospot;
	exports.LittlePlanet = LittlePlanet;
	exports.MODES = MODES;
	exports.Media = Media;
	exports.Panorama = Panorama;
	exports.REVISION = REVISION;
	exports.Reticle = Reticle;
	exports.THREE_REVISION = THREE_REVISION;
	exports.THREE_VERSION = THREE_VERSION;
	exports.TextureLoader = TextureLoader;
	exports.VERSION = VERSION;
	exports.VideoPanorama = VideoPanorama;
	exports.Viewer = Viewer;
	exports.Widget = Widget;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
